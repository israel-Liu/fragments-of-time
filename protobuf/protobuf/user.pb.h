// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base.pb.h"
// @@protoc_insertion_point(includes)

namespace tms {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class UTargetSelfparam;
class UserTargets;
class UTargetInfo;
class UTargetInfos;
class UserPrivateInfo;
class UserInfo;
class UserInfo_Old;
class UserOnlineInfo;
class LoginInfo;
class LoginAnsInfo;
class RegisterInfo;
class UserInfoReq;
class TargetsQuery;
class UpdateUserInfo;
class TargetsAdd;
class UpdateTargetInfo;
class UserInfoNotify;
class TargetsAddNotify;
class TargetsNotify;
class ServerTime;
class FileLoadInfo;
class FileLoadData;
class TalkMsg;
class TalkMsgAns;
class TmpTalkMsg;
class PullTalkMsgReq;
class MsgInfoNotify;
class MsgInfoNotify_MsgInfo;
class TalkMsgInfo;
class GroupPrivateInfo;
class JoinGTalk;
class AnsJoinGTalk;
class QuitGTalk;
class SysTargetInfo;
class SysTargetInfoList;
class SysMemberInfo;
class SysMemberInfoList;
class SysUserPrivateInfo;
class SysUserPrivateInfoList;
class SysGroupInfo;
class SysGroupInfoList;
class SysGTalkInfoList;
class SysUserInfo;
class SysTalkMsg;
class SysTalkMsgList;
class SysTargetMsgInfo;
class SysTargetMsgInfoList;

enum UserInfoReq_cmd {
  UserInfoReq_cmd_PublicInfo = 0,
  UserInfoReq_cmd_MemberList = 1,
  UserInfoReq_cmd_UserPrivateInfo = 2,
  UserInfoReq_cmd_UserInfo = 3,
  UserInfoReq_cmd_UserInfo_Old = 4,
  UserInfoReq_cmd_UTargetInfos = 5
};
bool UserInfoReq_cmd_IsValid(int value);
const UserInfoReq_cmd UserInfoReq_cmd_cmd_MIN = UserInfoReq_cmd_PublicInfo;
const UserInfoReq_cmd UserInfoReq_cmd_cmd_MAX = UserInfoReq_cmd_UTargetInfos;
const int UserInfoReq_cmd_cmd_ARRAYSIZE = UserInfoReq_cmd_cmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserInfoReq_cmd_descriptor();
inline const ::std::string& UserInfoReq_cmd_Name(UserInfoReq_cmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserInfoReq_cmd_descriptor(), value);
}
inline bool UserInfoReq_cmd_Parse(
    const ::std::string& name, UserInfoReq_cmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserInfoReq_cmd>(
    UserInfoReq_cmd_descriptor(), name, value);
}
enum TargetsAdd_cmd {
  TargetsAdd_cmd_Apply = 0,
  TargetsAdd_cmd_Applied = 1,
  TargetsAdd_cmd_Agree = 2,
  TargetsAdd_cmd_Agreed = 3,
  TargetsAdd_cmd_Refuse = 4,
  TargetsAdd_cmd_Refused = 5,
  TargetsAdd_cmd_Delete = 6,
  TargetsAdd_cmd_Deleted = 7,
  TargetsAdd_cmd_Fail = 8
};
bool TargetsAdd_cmd_IsValid(int value);
const TargetsAdd_cmd TargetsAdd_cmd_cmd_MIN = TargetsAdd_cmd_Apply;
const TargetsAdd_cmd TargetsAdd_cmd_cmd_MAX = TargetsAdd_cmd_Fail;
const int TargetsAdd_cmd_cmd_ARRAYSIZE = TargetsAdd_cmd_cmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* TargetsAdd_cmd_descriptor();
inline const ::std::string& TargetsAdd_cmd_Name(TargetsAdd_cmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    TargetsAdd_cmd_descriptor(), value);
}
inline bool TargetsAdd_cmd_Parse(
    const ::std::string& name, TargetsAdd_cmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TargetsAdd_cmd>(
    TargetsAdd_cmd_descriptor(), name, value);
}
// ===================================================================

class UTargetSelfparam : public ::google::protobuf::Message {
 public:
  UTargetSelfparam();
  virtual ~UTargetSelfparam();

  UTargetSelfparam(const UTargetSelfparam& from);

  inline UTargetSelfparam& operator=(const UTargetSelfparam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UTargetSelfparam& default_instance();

  void Swap(UTargetSelfparam* other);

  // implements Message ----------------------------------------------

  UTargetSelfparam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UTargetSelfparam& from);
  void MergeFrom(const UTargetSelfparam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes strNickName = 1;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 1;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const void* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // @@protoc_insertion_point(class_scope:tms.UTargetSelfparam)
 private:
  inline void set_has_strnickname();
  inline void clear_has_strnickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strnickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UTargetSelfparam* default_instance_;
};
// -------------------------------------------------------------------

class UserTargets : public ::google::protobuf::Message {
 public:
  UserTargets();
  virtual ~UserTargets();

  UserTargets(const UserTargets& from);

  inline UserTargets& operator=(const UserTargets& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTargets& default_instance();

  void Swap(UserTargets* other);

  // implements Message ----------------------------------------------

  UserTargets* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserTargets& from);
  void MergeFrom(const UserTargets& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.UTarget UTargets = 1;
  inline int utargets_size() const;
  inline void clear_utargets();
  static const int kUTargetsFieldNumber = 1;
  inline const ::tms::UTarget& utargets(int index) const;
  inline ::tms::UTarget* mutable_utargets(int index);
  inline ::tms::UTarget* add_utargets();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::UTarget >&
      utargets() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::UTarget >*
      mutable_utargets();

  // @@protoc_insertion_point(class_scope:tms.UserTargets)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::UTarget > utargets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserTargets* default_instance_;
};
// -------------------------------------------------------------------

class UTargetInfo : public ::google::protobuf::Message {
 public:
  UTargetInfo();
  virtual ~UTargetInfo();

  UTargetInfo(const UTargetInfo& from);

  inline UTargetInfo& operator=(const UTargetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UTargetInfo& default_instance();

  void Swap(UTargetInfo* other);

  // implements Message ----------------------------------------------

  UTargetInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UTargetInfo& from);
  void MergeFrom(const UTargetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tms.Targets Targets = 1;
  inline bool has_targets() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 1;
  inline const ::tms::Targets& targets() const;
  inline ::tms::Targets* mutable_targets();
  inline ::tms::Targets* release_targets();
  inline void set_allocated_targets(::tms::Targets* targets);

  // optional uint32 uRight = 2 [default = 0];
  inline bool has_uright() const;
  inline void clear_uright();
  static const int kURightFieldNumber = 2;
  inline ::google::protobuf::uint32 uright() const;
  inline void set_uright(::google::protobuf::uint32 value);

  // optional bytes selfparam = 3;
  inline bool has_selfparam() const;
  inline void clear_selfparam();
  static const int kSelfparamFieldNumber = 3;
  inline const ::std::string& selfparam() const;
  inline void set_selfparam(const ::std::string& value);
  inline void set_selfparam(const char* value);
  inline void set_selfparam(const void* value, size_t size);
  inline ::std::string* mutable_selfparam();
  inline ::std::string* release_selfparam();
  inline void set_allocated_selfparam(::std::string* selfparam);

  // @@protoc_insertion_point(class_scope:tms.UTargetInfo)
 private:
  inline void set_has_targets();
  inline void clear_has_targets();
  inline void set_has_uright();
  inline void clear_has_uright();
  inline void set_has_selfparam();
  inline void clear_has_selfparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tms::Targets* targets_;
  ::std::string* selfparam_;
  ::google::protobuf::uint32 uright_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UTargetInfo* default_instance_;
};
// -------------------------------------------------------------------

class UTargetInfos : public ::google::protobuf::Message {
 public:
  UTargetInfos();
  virtual ~UTargetInfos();

  UTargetInfos(const UTargetInfos& from);

  inline UTargetInfos& operator=(const UTargetInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UTargetInfos& default_instance();

  void Swap(UTargetInfos* other);

  // implements Message ----------------------------------------------

  UTargetInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UTargetInfos& from);
  void MergeFrom(const UTargetInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.UTargetInfo UTargetInfos = 1;
  inline int utargetinfos_size() const;
  inline void clear_utargetinfos();
  static const int kUTargetInfosFieldNumber = 1;
  inline const ::tms::UTargetInfo& utargetinfos(int index) const;
  inline ::tms::UTargetInfo* mutable_utargetinfos(int index);
  inline ::tms::UTargetInfo* add_utargetinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::UTargetInfo >&
      utargetinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::UTargetInfo >*
      mutable_utargetinfos();

  // @@protoc_insertion_point(class_scope:tms.UTargetInfos)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::UTargetInfo > utargetinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UTargetInfos* default_instance_;
};
// -------------------------------------------------------------------

class UserPrivateInfo : public ::google::protobuf::Message {
 public:
  UserPrivateInfo();
  virtual ~UserPrivateInfo();

  UserPrivateInfo(const UserPrivateInfo& from);

  inline UserPrivateInfo& operator=(const UserPrivateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPrivateInfo& default_instance();

  void Swap(UserPrivateInfo* other);

  // implements Message ----------------------------------------------

  UserPrivateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserPrivateInfo& from);
  void MergeFrom(const UserPrivateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 nGender = 1 [default = 0];
  inline bool has_ngender() const;
  inline void clear_ngender();
  static const int kNGenderFieldNumber = 1;
  inline ::google::protobuf::uint32 ngender() const;
  inline void set_ngender(::google::protobuf::uint32 value);

  // optional uint32 uBirthday = 2 [default = 0];
  inline bool has_ubirthday() const;
  inline void clear_ubirthday();
  static const int kUBirthdayFieldNumber = 2;
  inline ::google::protobuf::uint32 ubirthday() const;
  inline void set_ubirthday(::google::protobuf::uint32 value);

  // optional uint32 utmRegtime = 3 [default = 0];
  inline bool has_utmregtime() const;
  inline void clear_utmregtime();
  static const int kUtmRegtimeFieldNumber = 3;
  inline ::google::protobuf::uint32 utmregtime() const;
  inline void set_utmregtime(::google::protobuf::uint32 value);

  // optional uint32 nClientType = 4 [default = 0];
  inline bool has_nclienttype() const;
  inline void clear_nclienttype();
  static const int kNClientTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 nclienttype() const;
  inline void set_nclienttype(::google::protobuf::uint32 value);

  // optional bytes strSigature = 5;
  inline bool has_strsigature() const;
  inline void clear_strsigature();
  static const int kStrSigatureFieldNumber = 5;
  inline const ::std::string& strsigature() const;
  inline void set_strsigature(const ::std::string& value);
  inline void set_strsigature(const char* value);
  inline void set_strsigature(const void* value, size_t size);
  inline ::std::string* mutable_strsigature();
  inline ::std::string* release_strsigature();
  inline void set_allocated_strsigature(::std::string* strsigature);

  // optional bytes strCountry = 6;
  inline bool has_strcountry() const;
  inline void clear_strcountry();
  static const int kStrCountryFieldNumber = 6;
  inline const ::std::string& strcountry() const;
  inline void set_strcountry(const ::std::string& value);
  inline void set_strcountry(const char* value);
  inline void set_strcountry(const void* value, size_t size);
  inline ::std::string* mutable_strcountry();
  inline ::std::string* release_strcountry();
  inline void set_allocated_strcountry(::std::string* strcountry);

  // optional bytes strProvince = 7;
  inline bool has_strprovince() const;
  inline void clear_strprovince();
  static const int kStrProvinceFieldNumber = 7;
  inline const ::std::string& strprovince() const;
  inline void set_strprovince(const ::std::string& value);
  inline void set_strprovince(const char* value);
  inline void set_strprovince(const void* value, size_t size);
  inline ::std::string* mutable_strprovince();
  inline ::std::string* release_strprovince();
  inline void set_allocated_strprovince(::std::string* strprovince);

  // optional bytes strCity = 8;
  inline bool has_strcity() const;
  inline void clear_strcity();
  static const int kStrCityFieldNumber = 8;
  inline const ::std::string& strcity() const;
  inline void set_strcity(const ::std::string& value);
  inline void set_strcity(const char* value);
  inline void set_strcity(const void* value, size_t size);
  inline ::std::string* mutable_strcity();
  inline ::std::string* release_strcity();
  inline void set_allocated_strcity(::std::string* strcity);

  // optional bytes strPhone = 9;
  inline bool has_strphone() const;
  inline void clear_strphone();
  static const int kStrPhoneFieldNumber = 9;
  inline const ::std::string& strphone() const;
  inline void set_strphone(const ::std::string& value);
  inline void set_strphone(const char* value);
  inline void set_strphone(const void* value, size_t size);
  inline ::std::string* mutable_strphone();
  inline ::std::string* release_strphone();
  inline void set_allocated_strphone(::std::string* strphone);

  // optional bytes strMobile = 10;
  inline bool has_strmobile() const;
  inline void clear_strmobile();
  static const int kStrMobileFieldNumber = 10;
  inline const ::std::string& strmobile() const;
  inline void set_strmobile(const ::std::string& value);
  inline void set_strmobile(const char* value);
  inline void set_strmobile(const void* value, size_t size);
  inline ::std::string* mutable_strmobile();
  inline ::std::string* release_strmobile();
  inline void set_allocated_strmobile(::std::string* strmobile);

  // optional bytes strOccupation = 11;
  inline bool has_stroccupation() const;
  inline void clear_stroccupation();
  static const int kStrOccupationFieldNumber = 11;
  inline const ::std::string& stroccupation() const;
  inline void set_stroccupation(const ::std::string& value);
  inline void set_stroccupation(const char* value);
  inline void set_stroccupation(const void* value, size_t size);
  inline ::std::string* mutable_stroccupation();
  inline ::std::string* release_stroccupation();
  inline void set_allocated_stroccupation(::std::string* stroccupation);

  // optional bytes strCollege = 12;
  inline bool has_strcollege() const;
  inline void clear_strcollege();
  static const int kStrCollegeFieldNumber = 12;
  inline const ::std::string& strcollege() const;
  inline void set_strcollege(const ::std::string& value);
  inline void set_strcollege(const char* value);
  inline void set_strcollege(const void* value, size_t size);
  inline ::std::string* mutable_strcollege();
  inline ::std::string* release_strcollege();
  inline void set_allocated_strcollege(::std::string* strcollege);

  // optional bytes strEmail = 13;
  inline bool has_stremail() const;
  inline void clear_stremail();
  static const int kStrEmailFieldNumber = 13;
  inline const ::std::string& stremail() const;
  inline void set_stremail(const ::std::string& value);
  inline void set_stremail(const char* value);
  inline void set_stremail(const void* value, size_t size);
  inline ::std::string* mutable_stremail();
  inline ::std::string* release_stremail();
  inline void set_allocated_stremail(::std::string* stremail);

  // optional bytes strHomepage = 14;
  inline bool has_strhomepage() const;
  inline void clear_strhomepage();
  static const int kStrHomepageFieldNumber = 14;
  inline const ::std::string& strhomepage() const;
  inline void set_strhomepage(const ::std::string& value);
  inline void set_strhomepage(const char* value);
  inline void set_strhomepage(const void* value, size_t size);
  inline ::std::string* mutable_strhomepage();
  inline ::std::string* release_strhomepage();
  inline void set_allocated_strhomepage(::std::string* strhomepage);

  // optional bytes strPersonal = 15;
  inline bool has_strpersonal() const;
  inline void clear_strpersonal();
  static const int kStrPersonalFieldNumber = 15;
  inline const ::std::string& strpersonal() const;
  inline void set_strpersonal(const ::std::string& value);
  inline void set_strpersonal(const char* value);
  inline void set_strpersonal(const void* value, size_t size);
  inline ::std::string* mutable_strpersonal();
  inline ::std::string* release_strpersonal();
  inline void set_allocated_strpersonal(::std::string* strpersonal);

  // optional uint32 nShengXiao = 16;
  inline bool has_nshengxiao() const;
  inline void clear_nshengxiao();
  static const int kNShengXiaoFieldNumber = 16;
  inline ::google::protobuf::uint32 nshengxiao() const;
  inline void set_nshengxiao(::google::protobuf::uint32 value);

  // optional uint32 nConstel = 17;
  inline bool has_nconstel() const;
  inline void clear_nconstel();
  static const int kNConstelFieldNumber = 17;
  inline ::google::protobuf::uint32 nconstel() const;
  inline void set_nconstel(::google::protobuf::uint32 value);

  // optional uint32 nBlood = 18;
  inline bool has_nblood() const;
  inline void clear_nblood();
  static const int kNBloodFieldNumber = 18;
  inline ::google::protobuf::uint32 nblood() const;
  inline void set_nblood(::google::protobuf::uint32 value);

  // optional bytes strCustomFace = 19;
  inline bool has_strcustomface() const;
  inline void clear_strcustomface();
  static const int kStrCustomFaceFieldNumber = 19;
  inline const ::std::string& strcustomface() const;
  inline void set_strcustomface(const ::std::string& value);
  inline void set_strcustomface(const char* value);
  inline void set_strcustomface(const void* value, size_t size);
  inline ::std::string* mutable_strcustomface();
  inline ::std::string* release_strcustomface();
  inline void set_allocated_strcustomface(::std::string* strcustomface);

  // @@protoc_insertion_point(class_scope:tms.UserPrivateInfo)
 private:
  inline void set_has_ngender();
  inline void clear_has_ngender();
  inline void set_has_ubirthday();
  inline void clear_has_ubirthday();
  inline void set_has_utmregtime();
  inline void clear_has_utmregtime();
  inline void set_has_nclienttype();
  inline void clear_has_nclienttype();
  inline void set_has_strsigature();
  inline void clear_has_strsigature();
  inline void set_has_strcountry();
  inline void clear_has_strcountry();
  inline void set_has_strprovince();
  inline void clear_has_strprovince();
  inline void set_has_strcity();
  inline void clear_has_strcity();
  inline void set_has_strphone();
  inline void clear_has_strphone();
  inline void set_has_strmobile();
  inline void clear_has_strmobile();
  inline void set_has_stroccupation();
  inline void clear_has_stroccupation();
  inline void set_has_strcollege();
  inline void clear_has_strcollege();
  inline void set_has_stremail();
  inline void clear_has_stremail();
  inline void set_has_strhomepage();
  inline void clear_has_strhomepage();
  inline void set_has_strpersonal();
  inline void clear_has_strpersonal();
  inline void set_has_nshengxiao();
  inline void clear_has_nshengxiao();
  inline void set_has_nconstel();
  inline void clear_has_nconstel();
  inline void set_has_nblood();
  inline void clear_has_nblood();
  inline void set_has_strcustomface();
  inline void clear_has_strcustomface();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ngender_;
  ::google::protobuf::uint32 ubirthday_;
  ::google::protobuf::uint32 utmregtime_;
  ::google::protobuf::uint32 nclienttype_;
  ::std::string* strsigature_;
  ::std::string* strcountry_;
  ::std::string* strprovince_;
  ::std::string* strcity_;
  ::std::string* strphone_;
  ::std::string* strmobile_;
  ::std::string* stroccupation_;
  ::std::string* strcollege_;
  ::std::string* stremail_;
  ::std::string* strhomepage_;
  ::std::string* strpersonal_;
  ::google::protobuf::uint32 nshengxiao_;
  ::google::protobuf::uint32 nconstel_;
  ::std::string* strcustomface_;
  ::google::protobuf::uint32 nblood_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserPrivateInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tms.TargetInfo TargetInfos = 2;
  inline bool has_targetinfos() const;
  inline void clear_targetinfos();
  static const int kTargetInfosFieldNumber = 2;
  inline const ::tms::TargetInfo& targetinfos() const;
  inline ::tms::TargetInfo* mutable_targetinfos();
  inline ::tms::TargetInfo* release_targetinfos();
  inline void set_allocated_targetinfos(::tms::TargetInfo* targetinfos);

  // optional .tms.UserPrivateInfo PrivateInfos = 3;
  inline bool has_privateinfos() const;
  inline void clear_privateinfos();
  static const int kPrivateInfosFieldNumber = 3;
  inline const ::tms::UserPrivateInfo& privateinfos() const;
  inline ::tms::UserPrivateInfo* mutable_privateinfos();
  inline ::tms::UserPrivateInfo* release_privateinfos();
  inline void set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos);

  // @@protoc_insertion_point(class_scope:tms.UserInfo)
 private:
  inline void set_has_targetinfos();
  inline void clear_has_targetinfos();
  inline void set_has_privateinfos();
  inline void clear_has_privateinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tms::TargetInfo* targetinfos_;
  ::tms::UserPrivateInfo* privateinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo_Old : public ::google::protobuf::Message {
 public:
  UserInfo_Old();
  virtual ~UserInfo_Old();

  UserInfo_Old(const UserInfo_Old& from);

  inline UserInfo_Old& operator=(const UserInfo_Old& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo_Old& default_instance();

  void Swap(UserInfo_Old* other);

  // implements Message ----------------------------------------------

  UserInfo_Old* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo_Old& from);
  void MergeFrom(const UserInfo_Old& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tms.TargetInfo TargetInfos = 1;
  inline bool has_targetinfos() const;
  inline void clear_targetinfos();
  static const int kTargetInfosFieldNumber = 1;
  inline const ::tms::TargetInfo& targetinfos() const;
  inline ::tms::TargetInfo* mutable_targetinfos();
  inline ::tms::TargetInfo* release_targetinfos();
  inline void set_allocated_targetinfos(::tms::TargetInfo* targetinfos);

  // optional .tms.UserPrivateInfo PrivateInfos = 2;
  inline bool has_privateinfos() const;
  inline void clear_privateinfos();
  static const int kPrivateInfosFieldNumber = 2;
  inline const ::tms::UserPrivateInfo& privateinfos() const;
  inline ::tms::UserPrivateInfo* mutable_privateinfos();
  inline ::tms::UserPrivateInfo* release_privateinfos();
  inline void set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos);

  // optional .tms.TargetsNotify TargetsNotifys = 3;
  inline bool has_targetsnotifys() const;
  inline void clear_targetsnotifys();
  static const int kTargetsNotifysFieldNumber = 3;
  inline const ::tms::TargetsNotify& targetsnotifys() const;
  inline ::tms::TargetsNotify* mutable_targetsnotifys();
  inline ::tms::TargetsNotify* release_targetsnotifys();
  inline void set_allocated_targetsnotifys(::tms::TargetsNotify* targetsnotifys);

  // @@protoc_insertion_point(class_scope:tms.UserInfo_Old)
 private:
  inline void set_has_targetinfos();
  inline void clear_has_targetinfos();
  inline void set_has_privateinfos();
  inline void clear_has_privateinfos();
  inline void set_has_targetsnotifys();
  inline void clear_has_targetsnotifys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tms::TargetInfo* targetinfos_;
  ::tms::UserPrivateInfo* privateinfos_;
  ::tms::TargetsNotify* targetsnotifys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserInfo_Old* default_instance_;
};
// -------------------------------------------------------------------

class UserOnlineInfo : public ::google::protobuf::Message {
 public:
  UserOnlineInfo();
  virtual ~UserOnlineInfo();

  UserOnlineInfo(const UserOnlineInfo& from);

  inline UserOnlineInfo& operator=(const UserOnlineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserOnlineInfo& default_instance();

  void Swap(UserOnlineInfo* other);

  // implements Message ----------------------------------------------

  UserOnlineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserOnlineInfo& from);
  void MergeFrom(const UserOnlineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uAccountID = 1 [default = 0];
  inline bool has_uaccountid() const;
  inline void clear_uaccountid();
  static const int kUAccountIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uaccountid() const;
  inline void set_uaccountid(::google::protobuf::uint32 value);

  // required uint32 uLoginFlag = 2 [default = 0];
  inline bool has_uloginflag() const;
  inline void clear_uloginflag();
  static const int kULoginFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 uloginflag() const;
  inline void set_uloginflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.UserOnlineInfo)
 private:
  inline void set_has_uaccountid();
  inline void clear_has_uaccountid();
  inline void set_has_uloginflag();
  inline void clear_has_uloginflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uaccountid_;
  ::google::protobuf::uint32 uloginflag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserOnlineInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginInfo : public ::google::protobuf::Message {
 public:
  LoginInfo();
  virtual ~LoginInfo();

  LoginInfo(const LoginInfo& from);

  inline LoginInfo& operator=(const LoginInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginInfo& default_instance();

  void Swap(LoginInfo* other);

  // implements Message ----------------------------------------------

  LoginInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginInfo& from);
  void MergeFrom(const LoginInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strAccountNo = 1;
  inline bool has_straccountno() const;
  inline void clear_straccountno();
  static const int kStrAccountNoFieldNumber = 1;
  inline const ::std::string& straccountno() const;
  inline void set_straccountno(const ::std::string& value);
  inline void set_straccountno(const char* value);
  inline void set_straccountno(const char* value, size_t size);
  inline ::std::string* mutable_straccountno();
  inline ::std::string* release_straccountno();
  inline void set_allocated_straccountno(::std::string* straccountno);

  // required string strPasswd = 2;
  inline bool has_strpasswd() const;
  inline void clear_strpasswd();
  static const int kStrPasswdFieldNumber = 2;
  inline const ::std::string& strpasswd() const;
  inline void set_strpasswd(const ::std::string& value);
  inline void set_strpasswd(const char* value);
  inline void set_strpasswd(const char* value, size_t size);
  inline ::std::string* mutable_strpasswd();
  inline ::std::string* release_strpasswd();
  inline void set_allocated_strpasswd(::std::string* strpasswd);

  // optional uint32 uLoginFlags = 3 [default = 0];
  inline bool has_uloginflags() const;
  inline void clear_uloginflags();
  static const int kULoginFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 uloginflags() const;
  inline void set_uloginflags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.LoginInfo)
 private:
  inline void set_has_straccountno();
  inline void clear_has_straccountno();
  inline void set_has_strpasswd();
  inline void clear_has_strpasswd();
  inline void set_has_uloginflags();
  inline void clear_has_uloginflags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* straccountno_;
  ::std::string* strpasswd_;
  ::google::protobuf::uint32 uloginflags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static LoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginAnsInfo : public ::google::protobuf::Message {
 public:
  LoginAnsInfo();
  virtual ~LoginAnsInfo();

  LoginAnsInfo(const LoginAnsInfo& from);

  inline LoginAnsInfo& operator=(const LoginAnsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginAnsInfo& default_instance();

  void Swap(LoginAnsInfo* other);

  // implements Message ----------------------------------------------

  LoginAnsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginAnsInfo& from);
  void MergeFrom(const LoginAnsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uAccountID = 1;
  inline bool has_uaccountid() const;
  inline void clear_uaccountid();
  static const int kUAccountIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uaccountid() const;
  inline void set_uaccountid(::google::protobuf::uint32 value);

  // required uint32 uSessionID = 2;
  inline bool has_usessionid() const;
  inline void clear_usessionid();
  static const int kUSessionIDFieldNumber = 2;
  inline ::google::protobuf::uint32 usessionid() const;
  inline void set_usessionid(::google::protobuf::uint32 value);

  // required uint32 nClientType = 3 [default = 0];
  inline bool has_nclienttype() const;
  inline void clear_nclienttype();
  static const int kNClientTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 nclienttype() const;
  inline void set_nclienttype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.LoginAnsInfo)
 private:
  inline void set_has_uaccountid();
  inline void clear_has_uaccountid();
  inline void set_has_usessionid();
  inline void clear_has_usessionid();
  inline void set_has_nclienttype();
  inline void clear_has_nclienttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uaccountid_;
  ::google::protobuf::uint32 usessionid_;
  ::google::protobuf::uint32 nclienttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static LoginAnsInfo* default_instance_;
};
// -------------------------------------------------------------------

class RegisterInfo : public ::google::protobuf::Message {
 public:
  RegisterInfo();
  virtual ~RegisterInfo();

  RegisterInfo(const RegisterInfo& from);

  inline RegisterInfo& operator=(const RegisterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterInfo& default_instance();

  void Swap(RegisterInfo* other);

  // implements Message ----------------------------------------------

  RegisterInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterInfo& from);
  void MergeFrom(const RegisterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strAccountNo = 1;
  inline bool has_straccountno() const;
  inline void clear_straccountno();
  static const int kStrAccountNoFieldNumber = 1;
  inline const ::std::string& straccountno() const;
  inline void set_straccountno(const ::std::string& value);
  inline void set_straccountno(const char* value);
  inline void set_straccountno(const char* value, size_t size);
  inline ::std::string* mutable_straccountno();
  inline ::std::string* release_straccountno();
  inline void set_allocated_straccountno(::std::string* straccountno);

  // required string strPasswd = 2;
  inline bool has_strpasswd() const;
  inline void clear_strpasswd();
  static const int kStrPasswdFieldNumber = 2;
  inline const ::std::string& strpasswd() const;
  inline void set_strpasswd(const ::std::string& value);
  inline void set_strpasswd(const char* value);
  inline void set_strpasswd(const char* value, size_t size);
  inline ::std::string* mutable_strpasswd();
  inline ::std::string* release_strpasswd();
  inline void set_allocated_strpasswd(::std::string* strpasswd);

  // required bytes strNickName = 3;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 3;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const void* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // @@protoc_insertion_point(class_scope:tms.RegisterInfo)
 private:
  inline void set_has_straccountno();
  inline void clear_has_straccountno();
  inline void set_has_strpasswd();
  inline void clear_has_strpasswd();
  inline void set_has_strnickname();
  inline void clear_has_strnickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* straccountno_;
  ::std::string* strpasswd_;
  ::std::string* strnickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static RegisterInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoReq : public ::google::protobuf::Message {
 public:
  UserInfoReq();
  virtual ~UserInfoReq();

  UserInfoReq(const UserInfoReq& from);

  inline UserInfoReq& operator=(const UserInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoReq& default_instance();

  void Swap(UserInfoReq* other);

  // implements Message ----------------------------------------------

  UserInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoReq& from);
  void MergeFrom(const UserInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserInfoReq_cmd cmd;
  static const cmd PublicInfo = UserInfoReq_cmd_PublicInfo;
  static const cmd MemberList = UserInfoReq_cmd_MemberList;
  static const cmd UserPrivateInfo = UserInfoReq_cmd_UserPrivateInfo;
  static const cmd UserInfo = UserInfoReq_cmd_UserInfo;
  static const cmd UserInfo_Old = UserInfoReq_cmd_UserInfo_Old;
  static const cmd UTargetInfos = UserInfoReq_cmd_UTargetInfos;
  static inline bool cmd_IsValid(int value) {
    return UserInfoReq_cmd_IsValid(value);
  }
  static const cmd cmd_MIN =
    UserInfoReq_cmd_cmd_MIN;
  static const cmd cmd_MAX =
    UserInfoReq_cmd_cmd_MAX;
  static const int cmd_ARRAYSIZE =
    UserInfoReq_cmd_cmd_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  cmd_descriptor() {
    return UserInfoReq_cmd_descriptor();
  }
  static inline const ::std::string& cmd_Name(cmd value) {
    return UserInfoReq_cmd_Name(value);
  }
  static inline bool cmd_Parse(const ::std::string& name,
      cmd* value) {
    return UserInfoReq_cmd_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tms.UserInfoReq.cmd ncmd = 1 [default = UserInfo];
  inline bool has_ncmd() const;
  inline void clear_ncmd();
  static const int kNcmdFieldNumber = 1;
  inline ::tms::UserInfoReq_cmd ncmd() const;
  inline void set_ncmd(::tms::UserInfoReq_cmd value);

  // @@protoc_insertion_point(class_scope:tms.UserInfoReq)
 private:
  inline void set_has_ncmd();
  inline void clear_has_ncmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ncmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class TargetsQuery : public ::google::protobuf::Message {
 public:
  TargetsQuery();
  virtual ~TargetsQuery();

  TargetsQuery(const TargetsQuery& from);

  inline TargetsQuery& operator=(const TargetsQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetsQuery& default_instance();

  void Swap(TargetsQuery* other);

  // implements Message ----------------------------------------------

  TargetsQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetsQuery& from);
  void MergeFrom(const TargetsQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string strAccountNo = 1;
  inline bool has_straccountno() const;
  inline void clear_straccountno();
  static const int kStrAccountNoFieldNumber = 1;
  inline const ::std::string& straccountno() const;
  inline void set_straccountno(const ::std::string& value);
  inline void set_straccountno(const char* value);
  inline void set_straccountno(const char* value, size_t size);
  inline ::std::string* mutable_straccountno();
  inline ::std::string* release_straccountno();
  inline void set_allocated_straccountno(::std::string* straccountno);

  // required bytes strNickName = 2;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 2;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const void* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // @@protoc_insertion_point(class_scope:tms.TargetsQuery)
 private:
  inline void set_has_straccountno();
  inline void clear_has_straccountno();
  inline void set_has_strnickname();
  inline void clear_has_strnickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* straccountno_;
  ::std::string* strnickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TargetsQuery* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserInfo : public ::google::protobuf::Message {
 public:
  UpdateUserInfo();
  virtual ~UpdateUserInfo();

  UpdateUserInfo(const UpdateUserInfo& from);

  inline UpdateUserInfo& operator=(const UpdateUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateUserInfo& default_instance();

  void Swap(UpdateUserInfo* other);

  // implements Message ----------------------------------------------

  UpdateUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateUserInfo& from);
  void MergeFrom(const UpdateUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes strNickName = 1;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 1;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const void* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // optional uint32 nFace = 2 [default = 0];
  inline bool has_nface() const;
  inline void clear_nface();
  static const int kNFaceFieldNumber = 2;
  inline ::google::protobuf::uint32 nface() const;
  inline void set_nface(::google::protobuf::uint32 value);

  // optional .tms.UserPrivateInfo PrivateInfos = 3;
  inline bool has_privateinfos() const;
  inline void clear_privateinfos();
  static const int kPrivateInfosFieldNumber = 3;
  inline const ::tms::UserPrivateInfo& privateinfos() const;
  inline ::tms::UserPrivateInfo* mutable_privateinfos();
  inline ::tms::UserPrivateInfo* release_privateinfos();
  inline void set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos);

  // @@protoc_insertion_point(class_scope:tms.UpdateUserInfo)
 private:
  inline void set_has_strnickname();
  inline void clear_has_strnickname();
  inline void set_has_nface();
  inline void clear_has_nface();
  inline void set_has_privateinfos();
  inline void clear_has_privateinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strnickname_;
  ::tms::UserPrivateInfo* privateinfos_;
  ::google::protobuf::uint32 nface_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class TargetsAdd : public ::google::protobuf::Message {
 public:
  TargetsAdd();
  virtual ~TargetsAdd();

  TargetsAdd(const TargetsAdd& from);

  inline TargetsAdd& operator=(const TargetsAdd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetsAdd& default_instance();

  void Swap(TargetsAdd* other);

  // implements Message ----------------------------------------------

  TargetsAdd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetsAdd& from);
  void MergeFrom(const TargetsAdd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TargetsAdd_cmd cmd;
  static const cmd Apply = TargetsAdd_cmd_Apply;
  static const cmd Applied = TargetsAdd_cmd_Applied;
  static const cmd Agree = TargetsAdd_cmd_Agree;
  static const cmd Agreed = TargetsAdd_cmd_Agreed;
  static const cmd Refuse = TargetsAdd_cmd_Refuse;
  static const cmd Refused = TargetsAdd_cmd_Refused;
  static const cmd Delete = TargetsAdd_cmd_Delete;
  static const cmd Deleted = TargetsAdd_cmd_Deleted;
  static const cmd Fail = TargetsAdd_cmd_Fail;
  static inline bool cmd_IsValid(int value) {
    return TargetsAdd_cmd_IsValid(value);
  }
  static const cmd cmd_MIN =
    TargetsAdd_cmd_cmd_MIN;
  static const cmd cmd_MAX =
    TargetsAdd_cmd_cmd_MAX;
  static const int cmd_ARRAYSIZE =
    TargetsAdd_cmd_cmd_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  cmd_descriptor() {
    return TargetsAdd_cmd_descriptor();
  }
  static inline const ::std::string& cmd_Name(cmd value) {
    return TargetsAdd_cmd_Name(value);
  }
  static inline bool cmd_Parse(const ::std::string& name,
      cmd* value) {
    return TargetsAdd_cmd_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 1 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // required .tms.TargetsAdd.cmd ncmd = 2 [default = Apply];
  inline bool has_ncmd() const;
  inline void clear_ncmd();
  static const int kNcmdFieldNumber = 2;
  inline ::tms::TargetsAdd_cmd ncmd() const;
  inline void set_ncmd(::tms::TargetsAdd_cmd value);

  // @@protoc_insertion_point(class_scope:tms.TargetsAdd)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_ncmd();
  inline void clear_has_ncmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 utargetid_;
  int ncmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TargetsAdd* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTargetInfo : public ::google::protobuf::Message {
 public:
  UpdateTargetInfo();
  virtual ~UpdateTargetInfo();

  UpdateTargetInfo(const UpdateTargetInfo& from);

  inline UpdateTargetInfo& operator=(const UpdateTargetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTargetInfo& default_instance();

  void Swap(UpdateTargetInfo* other);

  // implements Message ----------------------------------------------

  UpdateTargetInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTargetInfo& from);
  void MergeFrom(const UpdateTargetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 1 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // optional bytes strNickName = 2;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 2;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const void* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // optional bytes selfparam = 3;
  inline bool has_selfparam() const;
  inline void clear_selfparam();
  static const int kSelfparamFieldNumber = 3;
  inline const ::std::string& selfparam() const;
  inline void set_selfparam(const ::std::string& value);
  inline void set_selfparam(const char* value);
  inline void set_selfparam(const void* value, size_t size);
  inline ::std::string* mutable_selfparam();
  inline ::std::string* release_selfparam();
  inline void set_allocated_selfparam(::std::string* selfparam);

  // @@protoc_insertion_point(class_scope:tms.UpdateTargetInfo)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_strnickname();
  inline void clear_has_strnickname();
  inline void set_has_selfparam();
  inline void clear_has_selfparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strnickname_;
  ::std::string* selfparam_;
  ::google::protobuf::uint32 utargetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateTargetInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoNotify : public ::google::protobuf::Message {
 public:
  UserInfoNotify();
  virtual ~UserInfoNotify();

  UserInfoNotify(const UserInfoNotify& from);

  inline UserInfoNotify& operator=(const UserInfoNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoNotify& default_instance();

  void Swap(UserInfoNotify* other);

  // implements Message ----------------------------------------------

  UserInfoNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoNotify& from);
  void MergeFrom(const UserInfoNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uAccountID = 1 [default = 0];
  inline bool has_uaccountid() const;
  inline void clear_uaccountid();
  static const int kUAccountIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uaccountid() const;
  inline void set_uaccountid(::google::protobuf::uint32 value);

  // optional string strAccountNo = 2;
  inline bool has_straccountno() const;
  inline void clear_straccountno();
  static const int kStrAccountNoFieldNumber = 2;
  inline const ::std::string& straccountno() const;
  inline void set_straccountno(const ::std::string& value);
  inline void set_straccountno(const char* value);
  inline void set_straccountno(const char* value, size_t size);
  inline ::std::string* mutable_straccountno();
  inline ::std::string* release_straccountno();
  inline void set_allocated_straccountno(::std::string* straccountno);

  // optional bytes strNickName = 3;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 3;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const void* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // optional uint32 nFace = 4 [default = 0];
  inline bool has_nface() const;
  inline void clear_nface();
  static const int kNFaceFieldNumber = 4;
  inline ::google::protobuf::uint32 nface() const;
  inline void set_nface(::google::protobuf::uint32 value);

  // optional .tms.UserPrivateInfo PrivateInfos = 5;
  inline bool has_privateinfos() const;
  inline void clear_privateinfos();
  static const int kPrivateInfosFieldNumber = 5;
  inline const ::tms::UserPrivateInfo& privateinfos() const;
  inline ::tms::UserPrivateInfo* mutable_privateinfos();
  inline ::tms::UserPrivateInfo* release_privateinfos();
  inline void set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos);

  // @@protoc_insertion_point(class_scope:tms.UserInfoNotify)
 private:
  inline void set_has_uaccountid();
  inline void clear_has_uaccountid();
  inline void set_has_straccountno();
  inline void clear_has_straccountno();
  inline void set_has_strnickname();
  inline void clear_has_strnickname();
  inline void set_has_nface();
  inline void clear_has_nface();
  inline void set_has_privateinfos();
  inline void clear_has_privateinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* straccountno_;
  ::google::protobuf::uint32 uaccountid_;
  ::google::protobuf::uint32 nface_;
  ::std::string* strnickname_;
  ::tms::UserPrivateInfo* privateinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserInfoNotify* default_instance_;
};
// -------------------------------------------------------------------

class TargetsAddNotify : public ::google::protobuf::Message {
 public:
  TargetsAddNotify();
  virtual ~TargetsAddNotify();

  TargetsAddNotify(const TargetsAddNotify& from);

  inline TargetsAddNotify& operator=(const TargetsAddNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetsAddNotify& default_instance();

  void Swap(TargetsAddNotify* other);

  // implements Message ----------------------------------------------

  TargetsAddNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetsAddNotify& from);
  void MergeFrom(const TargetsAddNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tms.TargetsAdd TargetsAdds = 1;
  inline bool has_targetsadds() const;
  inline void clear_targetsadds();
  static const int kTargetsAddsFieldNumber = 1;
  inline const ::tms::TargetsAdd& targetsadds() const;
  inline ::tms::TargetsAdd* mutable_targetsadds();
  inline ::tms::TargetsAdd* release_targetsadds();
  inline void set_allocated_targetsadds(::tms::TargetsAdd* targetsadds);

  // required .tms.TargetInfo TargetInfos = 3;
  inline bool has_targetinfos() const;
  inline void clear_targetinfos();
  static const int kTargetInfosFieldNumber = 3;
  inline const ::tms::TargetInfo& targetinfos() const;
  inline ::tms::TargetInfo* mutable_targetinfos();
  inline ::tms::TargetInfo* release_targetinfos();
  inline void set_allocated_targetinfos(::tms::TargetInfo* targetinfos);

  // @@protoc_insertion_point(class_scope:tms.TargetsAddNotify)
 private:
  inline void set_has_targetsadds();
  inline void clear_has_targetsadds();
  inline void set_has_targetinfos();
  inline void clear_has_targetinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tms::TargetsAdd* targetsadds_;
  ::tms::TargetInfo* targetinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TargetsAddNotify* default_instance_;
};
// -------------------------------------------------------------------

class TargetsNotify : public ::google::protobuf::Message {
 public:
  TargetsNotify();
  virtual ~TargetsNotify();

  TargetsNotify(const TargetsNotify& from);

  inline TargetsNotify& operator=(const TargetsNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetsNotify& default_instance();

  void Swap(TargetsNotify* other);

  // implements Message ----------------------------------------------

  TargetsNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetsNotify& from);
  void MergeFrom(const TargetsNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.Targets Targetss = 1;
  inline int targetss_size() const;
  inline void clear_targetss();
  static const int kTargetssFieldNumber = 1;
  inline const ::tms::Targets& targetss(int index) const;
  inline ::tms::Targets* mutable_targetss(int index);
  inline ::tms::Targets* add_targetss();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::Targets >&
      targetss() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::Targets >*
      mutable_targetss();

  // @@protoc_insertion_point(class_scope:tms.TargetsNotify)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::Targets > targetss_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TargetsNotify* default_instance_;
};
// -------------------------------------------------------------------

class ServerTime : public ::google::protobuf::Message {
 public:
  ServerTime();
  virtual ~ServerTime();

  ServerTime(const ServerTime& from);

  inline ServerTime& operator=(const ServerTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerTime& default_instance();

  void Swap(ServerTime* other);

  // implements Message ----------------------------------------------

  ServerTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerTime& from);
  void MergeFrom(const ServerTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uServerTime = 1;
  inline bool has_uservertime() const;
  inline void clear_uservertime();
  static const int kUServerTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 uservertime() const;
  inline void set_uservertime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tms.ServerTime)
 private:
  inline void set_has_uservertime();
  inline void clear_has_uservertime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uservertime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static ServerTime* default_instance_;
};
// -------------------------------------------------------------------

class FileLoadInfo : public ::google::protobuf::Message {
 public:
  FileLoadInfo();
  virtual ~FileLoadInfo();

  FileLoadInfo(const FileLoadInfo& from);

  inline FileLoadInfo& operator=(const FileLoadInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileLoadInfo& default_instance();

  void Swap(FileLoadInfo* other);

  // implements Message ----------------------------------------------

  FileLoadInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileLoadInfo& from);
  void MergeFrom(const FileLoadInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes strName = 1;
  inline bool has_strname() const;
  inline void clear_strname();
  static const int kStrNameFieldNumber = 1;
  inline const ::std::string& strname() const;
  inline void set_strname(const ::std::string& value);
  inline void set_strname(const char* value);
  inline void set_strname(const void* value, size_t size);
  inline ::std::string* mutable_strname();
  inline ::std::string* release_strname();
  inline void set_allocated_strname(::std::string* strname);

  // required uint32 uOffset = 2;
  inline bool has_uoffset() const;
  inline void clear_uoffset();
  static const int kUOffsetFieldNumber = 2;
  inline ::google::protobuf::uint32 uoffset() const;
  inline void set_uoffset(::google::protobuf::uint32 value);

  // required uint32 uDownsize = 3;
  inline bool has_udownsize() const;
  inline void clear_udownsize();
  static const int kUDownsizeFieldNumber = 3;
  inline ::google::protobuf::uint32 udownsize() const;
  inline void set_udownsize(::google::protobuf::uint32 value);

  // required uint32 uLocalsize = 4;
  inline bool has_ulocalsize() const;
  inline void clear_ulocalsize();
  static const int kULocalsizeFieldNumber = 4;
  inline ::google::protobuf::uint32 ulocalsize() const;
  inline void set_ulocalsize(::google::protobuf::uint32 value);

  // required uint32 uLocaltime = 5;
  inline bool has_ulocaltime() const;
  inline void clear_ulocaltime();
  static const int kULocaltimeFieldNumber = 5;
  inline ::google::protobuf::uint32 ulocaltime() const;
  inline void set_ulocaltime(::google::protobuf::uint32 value);

  // required uint32 bVersion = 6;
  inline bool has_bversion() const;
  inline void clear_bversion();
  static const int kBVersionFieldNumber = 6;
  inline ::google::protobuf::uint32 bversion() const;
  inline void set_bversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.FileLoadInfo)
 private:
  inline void set_has_strname();
  inline void clear_has_strname();
  inline void set_has_uoffset();
  inline void clear_has_uoffset();
  inline void set_has_udownsize();
  inline void clear_has_udownsize();
  inline void set_has_ulocalsize();
  inline void clear_has_ulocalsize();
  inline void set_has_ulocaltime();
  inline void clear_has_ulocaltime();
  inline void set_has_bversion();
  inline void clear_has_bversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strname_;
  ::google::protobuf::uint32 uoffset_;
  ::google::protobuf::uint32 udownsize_;
  ::google::protobuf::uint32 ulocalsize_;
  ::google::protobuf::uint32 ulocaltime_;
  ::google::protobuf::uint32 bversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static FileLoadInfo* default_instance_;
};
// -------------------------------------------------------------------

class FileLoadData : public ::google::protobuf::Message {
 public:
  FileLoadData();
  virtual ~FileLoadData();

  FileLoadData(const FileLoadData& from);

  inline FileLoadData& operator=(const FileLoadData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileLoadData& default_instance();

  void Swap(FileLoadData* other);

  // implements Message ----------------------------------------------

  FileLoadData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileLoadData& from);
  void MergeFrom(const FileLoadData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uError = 1;
  inline bool has_uerror() const;
  inline void clear_uerror();
  static const int kUErrorFieldNumber = 1;
  inline ::google::protobuf::uint32 uerror() const;
  inline void set_uerror(::google::protobuf::uint32 value);

  // required uint32 uFilesize = 2;
  inline bool has_ufilesize() const;
  inline void clear_ufilesize();
  static const int kUFilesizeFieldNumber = 2;
  inline ::google::protobuf::uint32 ufilesize() const;
  inline void set_ufilesize(::google::protobuf::uint32 value);

  // required uint32 uOffset = 3;
  inline bool has_uoffset() const;
  inline void clear_uoffset();
  static const int kUOffsetFieldNumber = 3;
  inline ::google::protobuf::uint32 uoffset() const;
  inline void set_uoffset(::google::protobuf::uint32 value);

  // required uint32 uDownsize = 4;
  inline bool has_udownsize() const;
  inline void clear_udownsize();
  static const int kUDownsizeFieldNumber = 4;
  inline ::google::protobuf::uint32 udownsize() const;
  inline void set_udownsize(::google::protobuf::uint32 value);

  // required uint32 uTmmodified = 5;
  inline bool has_utmmodified() const;
  inline void clear_utmmodified();
  static const int kUTmmodifiedFieldNumber = 5;
  inline ::google::protobuf::uint32 utmmodified() const;
  inline void set_utmmodified(::google::protobuf::uint32 value);

  // optional bytes szData = 6;
  inline bool has_szdata() const;
  inline void clear_szdata();
  static const int kSzDataFieldNumber = 6;
  inline const ::std::string& szdata() const;
  inline void set_szdata(const ::std::string& value);
  inline void set_szdata(const char* value);
  inline void set_szdata(const void* value, size_t size);
  inline ::std::string* mutable_szdata();
  inline ::std::string* release_szdata();
  inline void set_allocated_szdata(::std::string* szdata);

  // @@protoc_insertion_point(class_scope:tms.FileLoadData)
 private:
  inline void set_has_uerror();
  inline void clear_has_uerror();
  inline void set_has_ufilesize();
  inline void clear_has_ufilesize();
  inline void set_has_uoffset();
  inline void clear_has_uoffset();
  inline void set_has_udownsize();
  inline void clear_has_udownsize();
  inline void set_has_utmmodified();
  inline void clear_has_utmmodified();
  inline void set_has_szdata();
  inline void clear_has_szdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uerror_;
  ::google::protobuf::uint32 ufilesize_;
  ::google::protobuf::uint32 uoffset_;
  ::google::protobuf::uint32 udownsize_;
  ::std::string* szdata_;
  ::google::protobuf::uint32 utmmodified_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static FileLoadData* default_instance_;
};
// -------------------------------------------------------------------

class TalkMsg : public ::google::protobuf::Message {
 public:
  TalkMsg();
  virtual ~TalkMsg();

  TalkMsg(const TalkMsg& from);

  inline TalkMsg& operator=(const TalkMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TalkMsg& default_instance();

  void Swap(TalkMsg* other);

  // implements Message ----------------------------------------------

  TalkMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TalkMsg& from);
  void MergeFrom(const TalkMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uSendID = 1 [default = 0];
  inline bool has_usendid() const;
  inline void clear_usendid();
  static const int kUSendIDFieldNumber = 1;
  inline ::google::protobuf::uint32 usendid() const;
  inline void set_usendid(::google::protobuf::uint32 value);

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // optional uint32 uMsgID = 3 [default = 0];
  inline bool has_umsgid() const;
  inline void clear_umsgid();
  static const int kUMsgIDFieldNumber = 3;
  inline ::google::protobuf::uint32 umsgid() const;
  inline void set_umsgid(::google::protobuf::uint32 value);

  // required bytes msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:tms.TalkMsg)
 private:
  inline void set_has_usendid();
  inline void clear_has_usendid();
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_umsgid();
  inline void clear_has_umsgid();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 usendid_;
  ::google::protobuf::uint32 utargetid_;
  ::std::string* msg_;
  ::google::protobuf::uint32 umsgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TalkMsg* default_instance_;
};
// -------------------------------------------------------------------

class TalkMsgAns : public ::google::protobuf::Message {
 public:
  TalkMsgAns();
  virtual ~TalkMsgAns();

  TalkMsgAns(const TalkMsgAns& from);

  inline TalkMsgAns& operator=(const TalkMsgAns& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TalkMsgAns& default_instance();

  void Swap(TalkMsgAns* other);

  // implements Message ----------------------------------------------

  TalkMsgAns* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TalkMsgAns& from);
  void MergeFrom(const TalkMsgAns& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uError = 1 [default = 0];
  inline bool has_uerror() const;
  inline void clear_uerror();
  static const int kUErrorFieldNumber = 1;
  inline ::google::protobuf::uint32 uerror() const;
  inline void set_uerror(::google::protobuf::uint32 value);

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // required uint32 uMsgID = 3 [default = 0];
  inline bool has_umsgid() const;
  inline void clear_umsgid();
  static const int kUMsgIDFieldNumber = 3;
  inline ::google::protobuf::uint32 umsgid() const;
  inline void set_umsgid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.TalkMsgAns)
 private:
  inline void set_has_uerror();
  inline void clear_has_uerror();
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_umsgid();
  inline void clear_has_umsgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uerror_;
  ::google::protobuf::uint32 utargetid_;
  ::google::protobuf::uint32 umsgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TalkMsgAns* default_instance_;
};
// -------------------------------------------------------------------

class TmpTalkMsg : public ::google::protobuf::Message {
 public:
  TmpTalkMsg();
  virtual ~TmpTalkMsg();

  TmpTalkMsg(const TmpTalkMsg& from);

  inline TmpTalkMsg& operator=(const TmpTalkMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TmpTalkMsg& default_instance();

  void Swap(TmpTalkMsg* other);

  // implements Message ----------------------------------------------

  TmpTalkMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TmpTalkMsg& from);
  void MergeFrom(const TmpTalkMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 1 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // required bytes strNickName = 2;
  inline bool has_strnickname() const;
  inline void clear_strnickname();
  static const int kStrNickNameFieldNumber = 2;
  inline const ::std::string& strnickname() const;
  inline void set_strnickname(const ::std::string& value);
  inline void set_strnickname(const char* value);
  inline void set_strnickname(const void* value, size_t size);
  inline ::std::string* mutable_strnickname();
  inline ::std::string* release_strnickname();
  inline void set_allocated_strnickname(::std::string* strnickname);

  // optional uint32 uMsgID = 3 [default = 0];
  inline bool has_umsgid() const;
  inline void clear_umsgid();
  static const int kUMsgIDFieldNumber = 3;
  inline ::google::protobuf::uint32 umsgid() const;
  inline void set_umsgid(::google::protobuf::uint32 value);

  // required bytes msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:tms.TmpTalkMsg)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_strnickname();
  inline void clear_has_strnickname();
  inline void set_has_umsgid();
  inline void clear_has_umsgid();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strnickname_;
  ::google::protobuf::uint32 utargetid_;
  ::google::protobuf::uint32 umsgid_;
  ::std::string* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TmpTalkMsg* default_instance_;
};
// -------------------------------------------------------------------

class PullTalkMsgReq : public ::google::protobuf::Message {
 public:
  PullTalkMsgReq();
  virtual ~PullTalkMsgReq();

  PullTalkMsgReq(const PullTalkMsgReq& from);

  inline PullTalkMsgReq& operator=(const PullTalkMsgReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PullTalkMsgReq& default_instance();

  void Swap(PullTalkMsgReq* other);

  // implements Message ----------------------------------------------

  PullTalkMsgReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PullTalkMsgReq& from);
  void MergeFrom(const PullTalkMsgReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 1 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // required uint32 uMsgID = 2 [default = 0];
  inline bool has_umsgid() const;
  inline void clear_umsgid();
  static const int kUMsgIDFieldNumber = 2;
  inline ::google::protobuf::uint32 umsgid() const;
  inline void set_umsgid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.PullTalkMsgReq)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_umsgid();
  inline void clear_has_umsgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 utargetid_;
  ::google::protobuf::uint32 umsgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static PullTalkMsgReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgInfoNotify_MsgInfo : public ::google::protobuf::Message {
 public:
  MsgInfoNotify_MsgInfo();
  virtual ~MsgInfoNotify_MsgInfo();

  MsgInfoNotify_MsgInfo(const MsgInfoNotify_MsgInfo& from);

  inline MsgInfoNotify_MsgInfo& operator=(const MsgInfoNotify_MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgInfoNotify_MsgInfo& default_instance();

  void Swap(MsgInfoNotify_MsgInfo* other);

  // implements Message ----------------------------------------------

  MsgInfoNotify_MsgInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgInfoNotify_MsgInfo& from);
  void MergeFrom(const MsgInfoNotify_MsgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 1 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // required uint32 uMsgID = 2 [default = 0];
  inline bool has_umsgid() const;
  inline void clear_umsgid();
  static const int kUMsgIDFieldNumber = 2;
  inline ::google::protobuf::uint32 umsgid() const;
  inline void set_umsgid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.MsgInfoNotify.MsgInfo)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_umsgid();
  inline void clear_has_umsgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 utargetid_;
  ::google::protobuf::uint32 umsgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgInfoNotify_MsgInfo* default_instance_;
};
// -------------------------------------------------------------------

class MsgInfoNotify : public ::google::protobuf::Message {
 public:
  MsgInfoNotify();
  virtual ~MsgInfoNotify();

  MsgInfoNotify(const MsgInfoNotify& from);

  inline MsgInfoNotify& operator=(const MsgInfoNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgInfoNotify& default_instance();

  void Swap(MsgInfoNotify* other);

  // implements Message ----------------------------------------------

  MsgInfoNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgInfoNotify& from);
  void MergeFrom(const MsgInfoNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MsgInfoNotify_MsgInfo MsgInfo;

  // accessors -------------------------------------------------------

  // repeated .tms.MsgInfoNotify.MsgInfo MsgInfos = 1;
  inline int msginfos_size() const;
  inline void clear_msginfos();
  static const int kMsgInfosFieldNumber = 1;
  inline const ::tms::MsgInfoNotify_MsgInfo& msginfos(int index) const;
  inline ::tms::MsgInfoNotify_MsgInfo* mutable_msginfos(int index);
  inline ::tms::MsgInfoNotify_MsgInfo* add_msginfos();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::MsgInfoNotify_MsgInfo >&
      msginfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::MsgInfoNotify_MsgInfo >*
      mutable_msginfos();

  // @@protoc_insertion_point(class_scope:tms.MsgInfoNotify)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::MsgInfoNotify_MsgInfo > msginfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MsgInfoNotify* default_instance_;
};
// -------------------------------------------------------------------

class TalkMsgInfo : public ::google::protobuf::Message {
 public:
  TalkMsgInfo();
  virtual ~TalkMsgInfo();

  TalkMsgInfo(const TalkMsgInfo& from);

  inline TalkMsgInfo& operator=(const TalkMsgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TalkMsgInfo& default_instance();

  void Swap(TalkMsgInfo* other);

  // implements Message ----------------------------------------------

  TalkMsgInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TalkMsgInfo& from);
  void MergeFrom(const TalkMsgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // repeated .tms.TalkMsg TalkMsgs = 3;
  inline int talkmsgs_size() const;
  inline void clear_talkmsgs();
  static const int kTalkMsgsFieldNumber = 3;
  inline const ::tms::TalkMsg& talkmsgs(int index) const;
  inline ::tms::TalkMsg* mutable_talkmsgs(int index);
  inline ::tms::TalkMsg* add_talkmsgs();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::TalkMsg >&
      talkmsgs() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::TalkMsg >*
      mutable_talkmsgs();

  // @@protoc_insertion_point(class_scope:tms.TalkMsgInfo)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::TalkMsg > talkmsgs_;
  ::google::protobuf::uint32 utargetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TalkMsgInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupPrivateInfo : public ::google::protobuf::Message {
 public:
  GroupPrivateInfo();
  virtual ~GroupPrivateInfo();

  GroupPrivateInfo(const GroupPrivateInfo& from);

  inline GroupPrivateInfo& operator=(const GroupPrivateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPrivateInfo& default_instance();

  void Swap(GroupPrivateInfo* other);

  // implements Message ----------------------------------------------

  GroupPrivateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPrivateInfo& from);
  void MergeFrom(const GroupPrivateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tms.GroupPrivateInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GroupPrivateInfo* default_instance_;
};
// -------------------------------------------------------------------

class JoinGTalk : public ::google::protobuf::Message {
 public:
  JoinGTalk();
  virtual ~JoinGTalk();

  JoinGTalk(const JoinGTalk& from);

  inline JoinGTalk& operator=(const JoinGTalk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinGTalk& default_instance();

  void Swap(JoinGTalk* other);

  // implements Message ----------------------------------------------

  JoinGTalk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinGTalk& from);
  void MergeFrom(const JoinGTalk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 1 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // required uint32 uGTalkID = 2 [default = 0];
  inline bool has_ugtalkid() const;
  inline void clear_ugtalkid();
  static const int kUGTalkIDFieldNumber = 2;
  inline ::google::protobuf::uint32 ugtalkid() const;
  inline void set_ugtalkid(::google::protobuf::uint32 value);

  // optional .tms.TargetInfo TargetInfos = 3;
  inline bool has_targetinfos() const;
  inline void clear_targetinfos();
  static const int kTargetInfosFieldNumber = 3;
  inline const ::tms::TargetInfo& targetinfos() const;
  inline ::tms::TargetInfo* mutable_targetinfos();
  inline ::tms::TargetInfo* release_targetinfos();
  inline void set_allocated_targetinfos(::tms::TargetInfo* targetinfos);

  // @@protoc_insertion_point(class_scope:tms.JoinGTalk)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_ugtalkid();
  inline void clear_has_ugtalkid();
  inline void set_has_targetinfos();
  inline void clear_has_targetinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 utargetid_;
  ::google::protobuf::uint32 ugtalkid_;
  ::tms::TargetInfo* targetinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static JoinGTalk* default_instance_;
};
// -------------------------------------------------------------------

class AnsJoinGTalk : public ::google::protobuf::Message {
 public:
  AnsJoinGTalk();
  virtual ~AnsJoinGTalk();

  AnsJoinGTalk(const AnsJoinGTalk& from);

  inline AnsJoinGTalk& operator=(const AnsJoinGTalk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnsJoinGTalk& default_instance();

  void Swap(AnsJoinGTalk* other);

  // implements Message ----------------------------------------------

  AnsJoinGTalk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnsJoinGTalk& from);
  void MergeFrom(const AnsJoinGTalk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 1 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // required uint32 uGTalkID = 2 [default = 0];
  inline bool has_ugtalkid() const;
  inline void clear_ugtalkid();
  static const int kUGTalkIDFieldNumber = 2;
  inline ::google::protobuf::uint32 ugtalkid() const;
  inline void set_ugtalkid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.AnsJoinGTalk)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_ugtalkid();
  inline void clear_has_ugtalkid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 utargetid_;
  ::google::protobuf::uint32 ugtalkid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static AnsJoinGTalk* default_instance_;
};
// -------------------------------------------------------------------

class QuitGTalk : public ::google::protobuf::Message {
 public:
  QuitGTalk();
  virtual ~QuitGTalk();

  QuitGTalk(const QuitGTalk& from);

  inline QuitGTalk& operator=(const QuitGTalk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuitGTalk& default_instance();

  void Swap(QuitGTalk* other);

  // implements Message ----------------------------------------------

  QuitGTalk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuitGTalk& from);
  void MergeFrom(const QuitGTalk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uTargetID = 1 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 1;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // required uint32 uGTalkID = 2 [default = 0];
  inline bool has_ugtalkid() const;
  inline void clear_ugtalkid();
  static const int kUGTalkIDFieldNumber = 2;
  inline ::google::protobuf::uint32 ugtalkid() const;
  inline void set_ugtalkid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.QuitGTalk)
 private:
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_ugtalkid();
  inline void clear_has_ugtalkid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 utargetid_;
  ::google::protobuf::uint32 ugtalkid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static QuitGTalk* default_instance_;
};
// -------------------------------------------------------------------

class SysTargetInfo : public ::google::protobuf::Message {
 public:
  SysTargetInfo();
  virtual ~SysTargetInfo();

  SysTargetInfo(const SysTargetInfo& from);

  inline SysTargetInfo& operator=(const SysTargetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysTargetInfo& default_instance();

  void Swap(SysTargetInfo* other);

  // implements Message ----------------------------------------------

  SysTargetInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysTargetInfo& from);
  void MergeFrom(const SysTargetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uVersion = 1 [default = 0];
  inline bool has_uversion() const;
  inline void clear_uversion();
  static const int kUVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 uversion() const;
  inline void set_uversion(::google::protobuf::uint32 value);

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // optional .tms.TargetInfo objs = 3;
  inline bool has_objs() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 3;
  inline const ::tms::TargetInfo& objs() const;
  inline ::tms::TargetInfo* mutable_objs();
  inline ::tms::TargetInfo* release_objs();
  inline void set_allocated_objs(::tms::TargetInfo* objs);

  // @@protoc_insertion_point(class_scope:tms.SysTargetInfo)
 private:
  inline void set_has_uversion();
  inline void clear_has_uversion();
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_objs();
  inline void clear_has_objs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uversion_;
  ::google::protobuf::uint32 utargetid_;
  ::tms::TargetInfo* objs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysTargetInfo* default_instance_;
};
// -------------------------------------------------------------------

class SysTargetInfoList : public ::google::protobuf::Message {
 public:
  SysTargetInfoList();
  virtual ~SysTargetInfoList();

  SysTargetInfoList(const SysTargetInfoList& from);

  inline SysTargetInfoList& operator=(const SysTargetInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysTargetInfoList& default_instance();

  void Swap(SysTargetInfoList* other);

  // implements Message ----------------------------------------------

  SysTargetInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysTargetInfoList& from);
  void MergeFrom(const SysTargetInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.SysTargetInfo nodes = 2;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 2;
  inline const ::tms::SysTargetInfo& nodes(int index) const;
  inline ::tms::SysTargetInfo* mutable_nodes(int index);
  inline ::tms::SysTargetInfo* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::SysTargetInfo >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::SysTargetInfo >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:tms.SysTargetInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::SysTargetInfo > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysTargetInfoList* default_instance_;
};
// -------------------------------------------------------------------

class SysMemberInfo : public ::google::protobuf::Message {
 public:
  SysMemberInfo();
  virtual ~SysMemberInfo();

  SysMemberInfo(const SysMemberInfo& from);

  inline SysMemberInfo& operator=(const SysMemberInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysMemberInfo& default_instance();

  void Swap(SysMemberInfo* other);

  // implements Message ----------------------------------------------

  SysMemberInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysMemberInfo& from);
  void MergeFrom(const SysMemberInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uVersion = 1 [default = 0];
  inline bool has_uversion() const;
  inline void clear_uversion();
  static const int kUVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 uversion() const;
  inline void set_uversion(::google::protobuf::uint32 value);

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // optional .tms.MemberInfo objs = 3;
  inline bool has_objs() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 3;
  inline const ::tms::MemberInfo& objs() const;
  inline ::tms::MemberInfo* mutable_objs();
  inline ::tms::MemberInfo* release_objs();
  inline void set_allocated_objs(::tms::MemberInfo* objs);

  // @@protoc_insertion_point(class_scope:tms.SysMemberInfo)
 private:
  inline void set_has_uversion();
  inline void clear_has_uversion();
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_objs();
  inline void clear_has_objs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uversion_;
  ::google::protobuf::uint32 utargetid_;
  ::tms::MemberInfo* objs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysMemberInfo* default_instance_;
};
// -------------------------------------------------------------------

class SysMemberInfoList : public ::google::protobuf::Message {
 public:
  SysMemberInfoList();
  virtual ~SysMemberInfoList();

  SysMemberInfoList(const SysMemberInfoList& from);

  inline SysMemberInfoList& operator=(const SysMemberInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysMemberInfoList& default_instance();

  void Swap(SysMemberInfoList* other);

  // implements Message ----------------------------------------------

  SysMemberInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysMemberInfoList& from);
  void MergeFrom(const SysMemberInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uVersion = 1 [default = 0];
  inline bool has_uversion() const;
  inline void clear_uversion();
  static const int kUVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 uversion() const;
  inline void set_uversion(::google::protobuf::uint32 value);

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // repeated .tms.SysMemberInfo nodes = 3;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 3;
  inline const ::tms::SysMemberInfo& nodes(int index) const;
  inline ::tms::SysMemberInfo* mutable_nodes(int index);
  inline ::tms::SysMemberInfo* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::SysMemberInfo >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::SysMemberInfo >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:tms.SysMemberInfoList)
 private:
  inline void set_has_uversion();
  inline void clear_has_uversion();
  inline void set_has_utargetid();
  inline void clear_has_utargetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uversion_;
  ::google::protobuf::uint32 utargetid_;
  ::google::protobuf::RepeatedPtrField< ::tms::SysMemberInfo > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysMemberInfoList* default_instance_;
};
// -------------------------------------------------------------------

class SysUserPrivateInfo : public ::google::protobuf::Message {
 public:
  SysUserPrivateInfo();
  virtual ~SysUserPrivateInfo();

  SysUserPrivateInfo(const SysUserPrivateInfo& from);

  inline SysUserPrivateInfo& operator=(const SysUserPrivateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysUserPrivateInfo& default_instance();

  void Swap(SysUserPrivateInfo* other);

  // implements Message ----------------------------------------------

  SysUserPrivateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysUserPrivateInfo& from);
  void MergeFrom(const SysUserPrivateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uVersion = 1 [default = 0];
  inline bool has_uversion() const;
  inline void clear_uversion();
  static const int kUVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 uversion() const;
  inline void set_uversion(::google::protobuf::uint32 value);

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // optional .tms.UserPrivateInfo objs = 3;
  inline bool has_objs() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 3;
  inline const ::tms::UserPrivateInfo& objs() const;
  inline ::tms::UserPrivateInfo* mutable_objs();
  inline ::tms::UserPrivateInfo* release_objs();
  inline void set_allocated_objs(::tms::UserPrivateInfo* objs);

  // @@protoc_insertion_point(class_scope:tms.SysUserPrivateInfo)
 private:
  inline void set_has_uversion();
  inline void clear_has_uversion();
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_objs();
  inline void clear_has_objs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uversion_;
  ::google::protobuf::uint32 utargetid_;
  ::tms::UserPrivateInfo* objs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysUserPrivateInfo* default_instance_;
};
// -------------------------------------------------------------------

class SysUserPrivateInfoList : public ::google::protobuf::Message {
 public:
  SysUserPrivateInfoList();
  virtual ~SysUserPrivateInfoList();

  SysUserPrivateInfoList(const SysUserPrivateInfoList& from);

  inline SysUserPrivateInfoList& operator=(const SysUserPrivateInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysUserPrivateInfoList& default_instance();

  void Swap(SysUserPrivateInfoList* other);

  // implements Message ----------------------------------------------

  SysUserPrivateInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysUserPrivateInfoList& from);
  void MergeFrom(const SysUserPrivateInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.SysUserPrivateInfo nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::tms::SysUserPrivateInfo& nodes(int index) const;
  inline ::tms::SysUserPrivateInfo* mutable_nodes(int index);
  inline ::tms::SysUserPrivateInfo* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::SysUserPrivateInfo >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::SysUserPrivateInfo >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:tms.SysUserPrivateInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::SysUserPrivateInfo > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysUserPrivateInfoList* default_instance_;
};
// -------------------------------------------------------------------

class SysGroupInfo : public ::google::protobuf::Message {
 public:
  SysGroupInfo();
  virtual ~SysGroupInfo();

  SysGroupInfo(const SysGroupInfo& from);

  inline SysGroupInfo& operator=(const SysGroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysGroupInfo& default_instance();

  void Swap(SysGroupInfo* other);

  // implements Message ----------------------------------------------

  SysGroupInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysGroupInfo& from);
  void MergeFrom(const SysGroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uVersion = 1 [default = 0];
  inline bool has_uversion() const;
  inline void clear_uversion();
  static const int kUVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 uversion() const;
  inline void set_uversion(::google::protobuf::uint32 value);

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // optional .tms.GroupPrivateInfo objs = 4;
  inline bool has_objs() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 4;
  inline const ::tms::GroupPrivateInfo& objs() const;
  inline ::tms::GroupPrivateInfo* mutable_objs();
  inline ::tms::GroupPrivateInfo* release_objs();
  inline void set_allocated_objs(::tms::GroupPrivateInfo* objs);

  // @@protoc_insertion_point(class_scope:tms.SysGroupInfo)
 private:
  inline void set_has_uversion();
  inline void clear_has_uversion();
  inline void set_has_utargetid();
  inline void clear_has_utargetid();
  inline void set_has_objs();
  inline void clear_has_objs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uversion_;
  ::google::protobuf::uint32 utargetid_;
  ::tms::GroupPrivateInfo* objs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysGroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class SysGroupInfoList : public ::google::protobuf::Message {
 public:
  SysGroupInfoList();
  virtual ~SysGroupInfoList();

  SysGroupInfoList(const SysGroupInfoList& from);

  inline SysGroupInfoList& operator=(const SysGroupInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysGroupInfoList& default_instance();

  void Swap(SysGroupInfoList* other);

  // implements Message ----------------------------------------------

  SysGroupInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysGroupInfoList& from);
  void MergeFrom(const SysGroupInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.SysGroupInfo nodes = 3;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 3;
  inline const ::tms::SysGroupInfo& nodes(int index) const;
  inline ::tms::SysGroupInfo* mutable_nodes(int index);
  inline ::tms::SysGroupInfo* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::SysGroupInfo >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::SysGroupInfo >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:tms.SysGroupInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::SysGroupInfo > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysGroupInfoList* default_instance_;
};
// -------------------------------------------------------------------

class SysGTalkInfoList : public ::google::protobuf::Message {
 public:
  SysGTalkInfoList();
  virtual ~SysGTalkInfoList();

  SysGTalkInfoList(const SysGTalkInfoList& from);

  inline SysGTalkInfoList& operator=(const SysGTalkInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysGTalkInfoList& default_instance();

  void Swap(SysGTalkInfoList* other);

  // implements Message ----------------------------------------------

  SysGTalkInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysGTalkInfoList& from);
  void MergeFrom(const SysGTalkInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uVersion = 1 [default = 0];
  inline bool has_uversion() const;
  inline void clear_uversion();
  static const int kUVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 uversion() const;
  inline void set_uversion(::google::protobuf::uint32 value);

  // optional .tms.SysGroupInfoList objs = 3;
  inline bool has_objs() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 3;
  inline const ::tms::SysGroupInfoList& objs() const;
  inline ::tms::SysGroupInfoList* mutable_objs();
  inline ::tms::SysGroupInfoList* release_objs();
  inline void set_allocated_objs(::tms::SysGroupInfoList* objs);

  // @@protoc_insertion_point(class_scope:tms.SysGTalkInfoList)
 private:
  inline void set_has_uversion();
  inline void clear_has_uversion();
  inline void set_has_objs();
  inline void clear_has_objs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tms::SysGroupInfoList* objs_;
  ::google::protobuf::uint32 uversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysGTalkInfoList* default_instance_;
};
// -------------------------------------------------------------------

class SysUserInfo : public ::google::protobuf::Message {
 public:
  SysUserInfo();
  virtual ~SysUserInfo();

  SysUserInfo(const SysUserInfo& from);

  inline SysUserInfo& operator=(const SysUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysUserInfo& default_instance();

  void Swap(SysUserInfo* other);

  // implements Message ----------------------------------------------

  SysUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysUserInfo& from);
  void MergeFrom(const SysUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uVersion = 1 [default = 0];
  inline bool has_uversion() const;
  inline void clear_uversion();
  static const int kUVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 uversion() const;
  inline void set_uversion(::google::protobuf::uint32 value);

  // optional .tms.PrivateInfo PrivateInfos = 3;
  inline bool has_privateinfos() const;
  inline void clear_privateinfos();
  static const int kPrivateInfosFieldNumber = 3;
  inline const ::tms::PrivateInfo& privateinfos() const;
  inline ::tms::PrivateInfo* mutable_privateinfos();
  inline ::tms::PrivateInfo* release_privateinfos();
  inline void set_allocated_privateinfos(::tms::PrivateInfo* privateinfos);

  // @@protoc_insertion_point(class_scope:tms.SysUserInfo)
 private:
  inline void set_has_uversion();
  inline void clear_has_uversion();
  inline void set_has_privateinfos();
  inline void clear_has_privateinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tms::PrivateInfo* privateinfos_;
  ::google::protobuf::uint32 uversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class SysTalkMsg : public ::google::protobuf::Message {
 public:
  SysTalkMsg();
  virtual ~SysTalkMsg();

  SysTalkMsg(const SysTalkMsg& from);

  inline SysTalkMsg& operator=(const SysTalkMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysTalkMsg& default_instance();

  void Swap(SysTalkMsg* other);

  // implements Message ----------------------------------------------

  SysTalkMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysTalkMsg& from);
  void MergeFrom(const SysTalkMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uVersion = 1 [default = 0];
  inline bool has_uversion() const;
  inline void clear_uversion();
  static const int kUVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 uversion() const;
  inline void set_uversion(::google::protobuf::uint32 value);

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // repeated .tms.TalkMsg nodes = 3;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 3;
  inline const ::tms::TalkMsg& nodes(int index) const;
  inline ::tms::TalkMsg* mutable_nodes(int index);
  inline ::tms::TalkMsg* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::TalkMsg >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::TalkMsg >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:tms.SysTalkMsg)
 private:
  inline void set_has_uversion();
  inline void clear_has_uversion();
  inline void set_has_utargetid();
  inline void clear_has_utargetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uversion_;
  ::google::protobuf::uint32 utargetid_;
  ::google::protobuf::RepeatedPtrField< ::tms::TalkMsg > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysTalkMsg* default_instance_;
};
// -------------------------------------------------------------------

class SysTalkMsgList : public ::google::protobuf::Message {
 public:
  SysTalkMsgList();
  virtual ~SysTalkMsgList();

  SysTalkMsgList(const SysTalkMsgList& from);

  inline SysTalkMsgList& operator=(const SysTalkMsgList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysTalkMsgList& default_instance();

  void Swap(SysTalkMsgList* other);

  // implements Message ----------------------------------------------

  SysTalkMsgList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysTalkMsgList& from);
  void MergeFrom(const SysTalkMsgList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.SysTalkMsg nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::tms::SysTalkMsg& nodes(int index) const;
  inline ::tms::SysTalkMsg* mutable_nodes(int index);
  inline ::tms::SysTalkMsg* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::SysTalkMsg >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::SysTalkMsg >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:tms.SysTalkMsgList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::SysTalkMsg > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysTalkMsgList* default_instance_;
};
// -------------------------------------------------------------------

class SysTargetMsgInfo : public ::google::protobuf::Message {
 public:
  SysTargetMsgInfo();
  virtual ~SysTargetMsgInfo();

  SysTargetMsgInfo(const SysTargetMsgInfo& from);

  inline SysTargetMsgInfo& operator=(const SysTargetMsgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysTargetMsgInfo& default_instance();

  void Swap(SysTargetMsgInfo* other);

  // implements Message ----------------------------------------------

  SysTargetMsgInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysTargetMsgInfo& from);
  void MergeFrom(const SysTargetMsgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uVersion = 1 [default = 0];
  inline bool has_uversion() const;
  inline void clear_uversion();
  static const int kUVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 uversion() const;
  inline void set_uversion(::google::protobuf::uint32 value);

  // required uint32 uTargetID = 2 [default = 0];
  inline bool has_utargetid() const;
  inline void clear_utargetid();
  static const int kUTargetIDFieldNumber = 2;
  inline ::google::protobuf::uint32 utargetid() const;
  inline void set_utargetid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tms.SysTargetMsgInfo)
 private:
  inline void set_has_uversion();
  inline void clear_has_uversion();
  inline void set_has_utargetid();
  inline void clear_has_utargetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uversion_;
  ::google::protobuf::uint32 utargetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysTargetMsgInfo* default_instance_;
};
// -------------------------------------------------------------------

class SysTargetMsgInfoList : public ::google::protobuf::Message {
 public:
  SysTargetMsgInfoList();
  virtual ~SysTargetMsgInfoList();

  SysTargetMsgInfoList(const SysTargetMsgInfoList& from);

  inline SysTargetMsgInfoList& operator=(const SysTargetMsgInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysTargetMsgInfoList& default_instance();

  void Swap(SysTargetMsgInfoList* other);

  // implements Message ----------------------------------------------

  SysTargetMsgInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysTargetMsgInfoList& from);
  void MergeFrom(const SysTargetMsgInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tms.SysTargetMsgInfo nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::tms::SysTargetMsgInfo& nodes(int index) const;
  inline ::tms::SysTargetMsgInfo* mutable_nodes(int index);
  inline ::tms::SysTargetMsgInfo* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::tms::SysTargetMsgInfo >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::tms::SysTargetMsgInfo >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:tms.SysTargetMsgInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tms::SysTargetMsgInfo > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SysTargetMsgInfoList* default_instance_;
};
// ===================================================================


// ===================================================================

// UTargetSelfparam

// required bytes strNickName = 1;
inline bool UTargetSelfparam::has_strnickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UTargetSelfparam::set_has_strnickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UTargetSelfparam::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UTargetSelfparam::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& UTargetSelfparam::strnickname() const {
  return *strnickname_;
}
inline void UTargetSelfparam::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UTargetSelfparam::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UTargetSelfparam::set_strnickname(const void* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UTargetSelfparam::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* UTargetSelfparam::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UTargetSelfparam::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserTargets

// repeated .tms.UTarget UTargets = 1;
inline int UserTargets::utargets_size() const {
  return utargets_.size();
}
inline void UserTargets::clear_utargets() {
  utargets_.Clear();
}
inline const ::tms::UTarget& UserTargets::utargets(int index) const {
  return utargets_.Get(index);
}
inline ::tms::UTarget* UserTargets::mutable_utargets(int index) {
  return utargets_.Mutable(index);
}
inline ::tms::UTarget* UserTargets::add_utargets() {
  return utargets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::UTarget >&
UserTargets::utargets() const {
  return utargets_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::UTarget >*
UserTargets::mutable_utargets() {
  return &utargets_;
}

// -------------------------------------------------------------------

// UTargetInfo

// required .tms.Targets Targets = 1;
inline bool UTargetInfo::has_targets() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UTargetInfo::set_has_targets() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UTargetInfo::clear_has_targets() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UTargetInfo::clear_targets() {
  if (targets_ != NULL) targets_->::tms::Targets::Clear();
  clear_has_targets();
}
inline const ::tms::Targets& UTargetInfo::targets() const {
  return targets_ != NULL ? *targets_ : *default_instance_->targets_;
}
inline ::tms::Targets* UTargetInfo::mutable_targets() {
  set_has_targets();
  if (targets_ == NULL) targets_ = new ::tms::Targets;
  return targets_;
}
inline ::tms::Targets* UTargetInfo::release_targets() {
  clear_has_targets();
  ::tms::Targets* temp = targets_;
  targets_ = NULL;
  return temp;
}
inline void UTargetInfo::set_allocated_targets(::tms::Targets* targets) {
  delete targets_;
  targets_ = targets;
  if (targets) {
    set_has_targets();
  } else {
    clear_has_targets();
  }
}

// optional uint32 uRight = 2 [default = 0];
inline bool UTargetInfo::has_uright() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UTargetInfo::set_has_uright() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UTargetInfo::clear_has_uright() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UTargetInfo::clear_uright() {
  uright_ = 0u;
  clear_has_uright();
}
inline ::google::protobuf::uint32 UTargetInfo::uright() const {
  return uright_;
}
inline void UTargetInfo::set_uright(::google::protobuf::uint32 value) {
  set_has_uright();
  uright_ = value;
}

// optional bytes selfparam = 3;
inline bool UTargetInfo::has_selfparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UTargetInfo::set_has_selfparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UTargetInfo::clear_has_selfparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UTargetInfo::clear_selfparam() {
  if (selfparam_ != &::google::protobuf::internal::kEmptyString) {
    selfparam_->clear();
  }
  clear_has_selfparam();
}
inline const ::std::string& UTargetInfo::selfparam() const {
  return *selfparam_;
}
inline void UTargetInfo::set_selfparam(const ::std::string& value) {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  selfparam_->assign(value);
}
inline void UTargetInfo::set_selfparam(const char* value) {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  selfparam_->assign(value);
}
inline void UTargetInfo::set_selfparam(const void* value, size_t size) {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  selfparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UTargetInfo::mutable_selfparam() {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  return selfparam_;
}
inline ::std::string* UTargetInfo::release_selfparam() {
  clear_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfparam_;
    selfparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UTargetInfo::set_allocated_selfparam(::std::string* selfparam) {
  if (selfparam_ != &::google::protobuf::internal::kEmptyString) {
    delete selfparam_;
  }
  if (selfparam) {
    set_has_selfparam();
    selfparam_ = selfparam;
  } else {
    clear_has_selfparam();
    selfparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UTargetInfos

// repeated .tms.UTargetInfo UTargetInfos = 1;
inline int UTargetInfos::utargetinfos_size() const {
  return utargetinfos_.size();
}
inline void UTargetInfos::clear_utargetinfos() {
  utargetinfos_.Clear();
}
inline const ::tms::UTargetInfo& UTargetInfos::utargetinfos(int index) const {
  return utargetinfos_.Get(index);
}
inline ::tms::UTargetInfo* UTargetInfos::mutable_utargetinfos(int index) {
  return utargetinfos_.Mutable(index);
}
inline ::tms::UTargetInfo* UTargetInfos::add_utargetinfos() {
  return utargetinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::UTargetInfo >&
UTargetInfos::utargetinfos() const {
  return utargetinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::UTargetInfo >*
UTargetInfos::mutable_utargetinfos() {
  return &utargetinfos_;
}

// -------------------------------------------------------------------

// UserPrivateInfo

// optional uint32 nGender = 1 [default = 0];
inline bool UserPrivateInfo::has_ngender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPrivateInfo::set_has_ngender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPrivateInfo::clear_has_ngender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPrivateInfo::clear_ngender() {
  ngender_ = 0u;
  clear_has_ngender();
}
inline ::google::protobuf::uint32 UserPrivateInfo::ngender() const {
  return ngender_;
}
inline void UserPrivateInfo::set_ngender(::google::protobuf::uint32 value) {
  set_has_ngender();
  ngender_ = value;
}

// optional uint32 uBirthday = 2 [default = 0];
inline bool UserPrivateInfo::has_ubirthday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPrivateInfo::set_has_ubirthday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPrivateInfo::clear_has_ubirthday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPrivateInfo::clear_ubirthday() {
  ubirthday_ = 0u;
  clear_has_ubirthday();
}
inline ::google::protobuf::uint32 UserPrivateInfo::ubirthday() const {
  return ubirthday_;
}
inline void UserPrivateInfo::set_ubirthday(::google::protobuf::uint32 value) {
  set_has_ubirthday();
  ubirthday_ = value;
}

// optional uint32 utmRegtime = 3 [default = 0];
inline bool UserPrivateInfo::has_utmregtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserPrivateInfo::set_has_utmregtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserPrivateInfo::clear_has_utmregtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserPrivateInfo::clear_utmregtime() {
  utmregtime_ = 0u;
  clear_has_utmregtime();
}
inline ::google::protobuf::uint32 UserPrivateInfo::utmregtime() const {
  return utmregtime_;
}
inline void UserPrivateInfo::set_utmregtime(::google::protobuf::uint32 value) {
  set_has_utmregtime();
  utmregtime_ = value;
}

// optional uint32 nClientType = 4 [default = 0];
inline bool UserPrivateInfo::has_nclienttype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserPrivateInfo::set_has_nclienttype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserPrivateInfo::clear_has_nclienttype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserPrivateInfo::clear_nclienttype() {
  nclienttype_ = 0u;
  clear_has_nclienttype();
}
inline ::google::protobuf::uint32 UserPrivateInfo::nclienttype() const {
  return nclienttype_;
}
inline void UserPrivateInfo::set_nclienttype(::google::protobuf::uint32 value) {
  set_has_nclienttype();
  nclienttype_ = value;
}

// optional bytes strSigature = 5;
inline bool UserPrivateInfo::has_strsigature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserPrivateInfo::set_has_strsigature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserPrivateInfo::clear_has_strsigature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserPrivateInfo::clear_strsigature() {
  if (strsigature_ != &::google::protobuf::internal::kEmptyString) {
    strsigature_->clear();
  }
  clear_has_strsigature();
}
inline const ::std::string& UserPrivateInfo::strsigature() const {
  return *strsigature_;
}
inline void UserPrivateInfo::set_strsigature(const ::std::string& value) {
  set_has_strsigature();
  if (strsigature_ == &::google::protobuf::internal::kEmptyString) {
    strsigature_ = new ::std::string;
  }
  strsigature_->assign(value);
}
inline void UserPrivateInfo::set_strsigature(const char* value) {
  set_has_strsigature();
  if (strsigature_ == &::google::protobuf::internal::kEmptyString) {
    strsigature_ = new ::std::string;
  }
  strsigature_->assign(value);
}
inline void UserPrivateInfo::set_strsigature(const void* value, size_t size) {
  set_has_strsigature();
  if (strsigature_ == &::google::protobuf::internal::kEmptyString) {
    strsigature_ = new ::std::string;
  }
  strsigature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strsigature() {
  set_has_strsigature();
  if (strsigature_ == &::google::protobuf::internal::kEmptyString) {
    strsigature_ = new ::std::string;
  }
  return strsigature_;
}
inline ::std::string* UserPrivateInfo::release_strsigature() {
  clear_has_strsigature();
  if (strsigature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsigature_;
    strsigature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strsigature(::std::string* strsigature) {
  if (strsigature_ != &::google::protobuf::internal::kEmptyString) {
    delete strsigature_;
  }
  if (strsigature) {
    set_has_strsigature();
    strsigature_ = strsigature;
  } else {
    clear_has_strsigature();
    strsigature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strCountry = 6;
inline bool UserPrivateInfo::has_strcountry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserPrivateInfo::set_has_strcountry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserPrivateInfo::clear_has_strcountry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserPrivateInfo::clear_strcountry() {
  if (strcountry_ != &::google::protobuf::internal::kEmptyString) {
    strcountry_->clear();
  }
  clear_has_strcountry();
}
inline const ::std::string& UserPrivateInfo::strcountry() const {
  return *strcountry_;
}
inline void UserPrivateInfo::set_strcountry(const ::std::string& value) {
  set_has_strcountry();
  if (strcountry_ == &::google::protobuf::internal::kEmptyString) {
    strcountry_ = new ::std::string;
  }
  strcountry_->assign(value);
}
inline void UserPrivateInfo::set_strcountry(const char* value) {
  set_has_strcountry();
  if (strcountry_ == &::google::protobuf::internal::kEmptyString) {
    strcountry_ = new ::std::string;
  }
  strcountry_->assign(value);
}
inline void UserPrivateInfo::set_strcountry(const void* value, size_t size) {
  set_has_strcountry();
  if (strcountry_ == &::google::protobuf::internal::kEmptyString) {
    strcountry_ = new ::std::string;
  }
  strcountry_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strcountry() {
  set_has_strcountry();
  if (strcountry_ == &::google::protobuf::internal::kEmptyString) {
    strcountry_ = new ::std::string;
  }
  return strcountry_;
}
inline ::std::string* UserPrivateInfo::release_strcountry() {
  clear_has_strcountry();
  if (strcountry_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcountry_;
    strcountry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strcountry(::std::string* strcountry) {
  if (strcountry_ != &::google::protobuf::internal::kEmptyString) {
    delete strcountry_;
  }
  if (strcountry) {
    set_has_strcountry();
    strcountry_ = strcountry;
  } else {
    clear_has_strcountry();
    strcountry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strProvince = 7;
inline bool UserPrivateInfo::has_strprovince() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserPrivateInfo::set_has_strprovince() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserPrivateInfo::clear_has_strprovince() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserPrivateInfo::clear_strprovince() {
  if (strprovince_ != &::google::protobuf::internal::kEmptyString) {
    strprovince_->clear();
  }
  clear_has_strprovince();
}
inline const ::std::string& UserPrivateInfo::strprovince() const {
  return *strprovince_;
}
inline void UserPrivateInfo::set_strprovince(const ::std::string& value) {
  set_has_strprovince();
  if (strprovince_ == &::google::protobuf::internal::kEmptyString) {
    strprovince_ = new ::std::string;
  }
  strprovince_->assign(value);
}
inline void UserPrivateInfo::set_strprovince(const char* value) {
  set_has_strprovince();
  if (strprovince_ == &::google::protobuf::internal::kEmptyString) {
    strprovince_ = new ::std::string;
  }
  strprovince_->assign(value);
}
inline void UserPrivateInfo::set_strprovince(const void* value, size_t size) {
  set_has_strprovince();
  if (strprovince_ == &::google::protobuf::internal::kEmptyString) {
    strprovince_ = new ::std::string;
  }
  strprovince_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strprovince() {
  set_has_strprovince();
  if (strprovince_ == &::google::protobuf::internal::kEmptyString) {
    strprovince_ = new ::std::string;
  }
  return strprovince_;
}
inline ::std::string* UserPrivateInfo::release_strprovince() {
  clear_has_strprovince();
  if (strprovince_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strprovince_;
    strprovince_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strprovince(::std::string* strprovince) {
  if (strprovince_ != &::google::protobuf::internal::kEmptyString) {
    delete strprovince_;
  }
  if (strprovince) {
    set_has_strprovince();
    strprovince_ = strprovince;
  } else {
    clear_has_strprovince();
    strprovince_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strCity = 8;
inline bool UserPrivateInfo::has_strcity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserPrivateInfo::set_has_strcity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserPrivateInfo::clear_has_strcity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserPrivateInfo::clear_strcity() {
  if (strcity_ != &::google::protobuf::internal::kEmptyString) {
    strcity_->clear();
  }
  clear_has_strcity();
}
inline const ::std::string& UserPrivateInfo::strcity() const {
  return *strcity_;
}
inline void UserPrivateInfo::set_strcity(const ::std::string& value) {
  set_has_strcity();
  if (strcity_ == &::google::protobuf::internal::kEmptyString) {
    strcity_ = new ::std::string;
  }
  strcity_->assign(value);
}
inline void UserPrivateInfo::set_strcity(const char* value) {
  set_has_strcity();
  if (strcity_ == &::google::protobuf::internal::kEmptyString) {
    strcity_ = new ::std::string;
  }
  strcity_->assign(value);
}
inline void UserPrivateInfo::set_strcity(const void* value, size_t size) {
  set_has_strcity();
  if (strcity_ == &::google::protobuf::internal::kEmptyString) {
    strcity_ = new ::std::string;
  }
  strcity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strcity() {
  set_has_strcity();
  if (strcity_ == &::google::protobuf::internal::kEmptyString) {
    strcity_ = new ::std::string;
  }
  return strcity_;
}
inline ::std::string* UserPrivateInfo::release_strcity() {
  clear_has_strcity();
  if (strcity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcity_;
    strcity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strcity(::std::string* strcity) {
  if (strcity_ != &::google::protobuf::internal::kEmptyString) {
    delete strcity_;
  }
  if (strcity) {
    set_has_strcity();
    strcity_ = strcity;
  } else {
    clear_has_strcity();
    strcity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strPhone = 9;
inline bool UserPrivateInfo::has_strphone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserPrivateInfo::set_has_strphone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserPrivateInfo::clear_has_strphone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserPrivateInfo::clear_strphone() {
  if (strphone_ != &::google::protobuf::internal::kEmptyString) {
    strphone_->clear();
  }
  clear_has_strphone();
}
inline const ::std::string& UserPrivateInfo::strphone() const {
  return *strphone_;
}
inline void UserPrivateInfo::set_strphone(const ::std::string& value) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(value);
}
inline void UserPrivateInfo::set_strphone(const char* value) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(value);
}
inline void UserPrivateInfo::set_strphone(const void* value, size_t size) {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  strphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strphone() {
  set_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    strphone_ = new ::std::string;
  }
  return strphone_;
}
inline ::std::string* UserPrivateInfo::release_strphone() {
  clear_has_strphone();
  if (strphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strphone_;
    strphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strphone(::std::string* strphone) {
  if (strphone_ != &::google::protobuf::internal::kEmptyString) {
    delete strphone_;
  }
  if (strphone) {
    set_has_strphone();
    strphone_ = strphone;
  } else {
    clear_has_strphone();
    strphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strMobile = 10;
inline bool UserPrivateInfo::has_strmobile() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserPrivateInfo::set_has_strmobile() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserPrivateInfo::clear_has_strmobile() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserPrivateInfo::clear_strmobile() {
  if (strmobile_ != &::google::protobuf::internal::kEmptyString) {
    strmobile_->clear();
  }
  clear_has_strmobile();
}
inline const ::std::string& UserPrivateInfo::strmobile() const {
  return *strmobile_;
}
inline void UserPrivateInfo::set_strmobile(const ::std::string& value) {
  set_has_strmobile();
  if (strmobile_ == &::google::protobuf::internal::kEmptyString) {
    strmobile_ = new ::std::string;
  }
  strmobile_->assign(value);
}
inline void UserPrivateInfo::set_strmobile(const char* value) {
  set_has_strmobile();
  if (strmobile_ == &::google::protobuf::internal::kEmptyString) {
    strmobile_ = new ::std::string;
  }
  strmobile_->assign(value);
}
inline void UserPrivateInfo::set_strmobile(const void* value, size_t size) {
  set_has_strmobile();
  if (strmobile_ == &::google::protobuf::internal::kEmptyString) {
    strmobile_ = new ::std::string;
  }
  strmobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strmobile() {
  set_has_strmobile();
  if (strmobile_ == &::google::protobuf::internal::kEmptyString) {
    strmobile_ = new ::std::string;
  }
  return strmobile_;
}
inline ::std::string* UserPrivateInfo::release_strmobile() {
  clear_has_strmobile();
  if (strmobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmobile_;
    strmobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strmobile(::std::string* strmobile) {
  if (strmobile_ != &::google::protobuf::internal::kEmptyString) {
    delete strmobile_;
  }
  if (strmobile) {
    set_has_strmobile();
    strmobile_ = strmobile;
  } else {
    clear_has_strmobile();
    strmobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strOccupation = 11;
inline bool UserPrivateInfo::has_stroccupation() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserPrivateInfo::set_has_stroccupation() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserPrivateInfo::clear_has_stroccupation() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserPrivateInfo::clear_stroccupation() {
  if (stroccupation_ != &::google::protobuf::internal::kEmptyString) {
    stroccupation_->clear();
  }
  clear_has_stroccupation();
}
inline const ::std::string& UserPrivateInfo::stroccupation() const {
  return *stroccupation_;
}
inline void UserPrivateInfo::set_stroccupation(const ::std::string& value) {
  set_has_stroccupation();
  if (stroccupation_ == &::google::protobuf::internal::kEmptyString) {
    stroccupation_ = new ::std::string;
  }
  stroccupation_->assign(value);
}
inline void UserPrivateInfo::set_stroccupation(const char* value) {
  set_has_stroccupation();
  if (stroccupation_ == &::google::protobuf::internal::kEmptyString) {
    stroccupation_ = new ::std::string;
  }
  stroccupation_->assign(value);
}
inline void UserPrivateInfo::set_stroccupation(const void* value, size_t size) {
  set_has_stroccupation();
  if (stroccupation_ == &::google::protobuf::internal::kEmptyString) {
    stroccupation_ = new ::std::string;
  }
  stroccupation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_stroccupation() {
  set_has_stroccupation();
  if (stroccupation_ == &::google::protobuf::internal::kEmptyString) {
    stroccupation_ = new ::std::string;
  }
  return stroccupation_;
}
inline ::std::string* UserPrivateInfo::release_stroccupation() {
  clear_has_stroccupation();
  if (stroccupation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stroccupation_;
    stroccupation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_stroccupation(::std::string* stroccupation) {
  if (stroccupation_ != &::google::protobuf::internal::kEmptyString) {
    delete stroccupation_;
  }
  if (stroccupation) {
    set_has_stroccupation();
    stroccupation_ = stroccupation;
  } else {
    clear_has_stroccupation();
    stroccupation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strCollege = 12;
inline bool UserPrivateInfo::has_strcollege() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserPrivateInfo::set_has_strcollege() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserPrivateInfo::clear_has_strcollege() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserPrivateInfo::clear_strcollege() {
  if (strcollege_ != &::google::protobuf::internal::kEmptyString) {
    strcollege_->clear();
  }
  clear_has_strcollege();
}
inline const ::std::string& UserPrivateInfo::strcollege() const {
  return *strcollege_;
}
inline void UserPrivateInfo::set_strcollege(const ::std::string& value) {
  set_has_strcollege();
  if (strcollege_ == &::google::protobuf::internal::kEmptyString) {
    strcollege_ = new ::std::string;
  }
  strcollege_->assign(value);
}
inline void UserPrivateInfo::set_strcollege(const char* value) {
  set_has_strcollege();
  if (strcollege_ == &::google::protobuf::internal::kEmptyString) {
    strcollege_ = new ::std::string;
  }
  strcollege_->assign(value);
}
inline void UserPrivateInfo::set_strcollege(const void* value, size_t size) {
  set_has_strcollege();
  if (strcollege_ == &::google::protobuf::internal::kEmptyString) {
    strcollege_ = new ::std::string;
  }
  strcollege_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strcollege() {
  set_has_strcollege();
  if (strcollege_ == &::google::protobuf::internal::kEmptyString) {
    strcollege_ = new ::std::string;
  }
  return strcollege_;
}
inline ::std::string* UserPrivateInfo::release_strcollege() {
  clear_has_strcollege();
  if (strcollege_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcollege_;
    strcollege_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strcollege(::std::string* strcollege) {
  if (strcollege_ != &::google::protobuf::internal::kEmptyString) {
    delete strcollege_;
  }
  if (strcollege) {
    set_has_strcollege();
    strcollege_ = strcollege;
  } else {
    clear_has_strcollege();
    strcollege_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strEmail = 13;
inline bool UserPrivateInfo::has_stremail() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserPrivateInfo::set_has_stremail() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserPrivateInfo::clear_has_stremail() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserPrivateInfo::clear_stremail() {
  if (stremail_ != &::google::protobuf::internal::kEmptyString) {
    stremail_->clear();
  }
  clear_has_stremail();
}
inline const ::std::string& UserPrivateInfo::stremail() const {
  return *stremail_;
}
inline void UserPrivateInfo::set_stremail(const ::std::string& value) {
  set_has_stremail();
  if (stremail_ == &::google::protobuf::internal::kEmptyString) {
    stremail_ = new ::std::string;
  }
  stremail_->assign(value);
}
inline void UserPrivateInfo::set_stremail(const char* value) {
  set_has_stremail();
  if (stremail_ == &::google::protobuf::internal::kEmptyString) {
    stremail_ = new ::std::string;
  }
  stremail_->assign(value);
}
inline void UserPrivateInfo::set_stremail(const void* value, size_t size) {
  set_has_stremail();
  if (stremail_ == &::google::protobuf::internal::kEmptyString) {
    stremail_ = new ::std::string;
  }
  stremail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_stremail() {
  set_has_stremail();
  if (stremail_ == &::google::protobuf::internal::kEmptyString) {
    stremail_ = new ::std::string;
  }
  return stremail_;
}
inline ::std::string* UserPrivateInfo::release_stremail() {
  clear_has_stremail();
  if (stremail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stremail_;
    stremail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_stremail(::std::string* stremail) {
  if (stremail_ != &::google::protobuf::internal::kEmptyString) {
    delete stremail_;
  }
  if (stremail) {
    set_has_stremail();
    stremail_ = stremail;
  } else {
    clear_has_stremail();
    stremail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strHomepage = 14;
inline bool UserPrivateInfo::has_strhomepage() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserPrivateInfo::set_has_strhomepage() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserPrivateInfo::clear_has_strhomepage() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserPrivateInfo::clear_strhomepage() {
  if (strhomepage_ != &::google::protobuf::internal::kEmptyString) {
    strhomepage_->clear();
  }
  clear_has_strhomepage();
}
inline const ::std::string& UserPrivateInfo::strhomepage() const {
  return *strhomepage_;
}
inline void UserPrivateInfo::set_strhomepage(const ::std::string& value) {
  set_has_strhomepage();
  if (strhomepage_ == &::google::protobuf::internal::kEmptyString) {
    strhomepage_ = new ::std::string;
  }
  strhomepage_->assign(value);
}
inline void UserPrivateInfo::set_strhomepage(const char* value) {
  set_has_strhomepage();
  if (strhomepage_ == &::google::protobuf::internal::kEmptyString) {
    strhomepage_ = new ::std::string;
  }
  strhomepage_->assign(value);
}
inline void UserPrivateInfo::set_strhomepage(const void* value, size_t size) {
  set_has_strhomepage();
  if (strhomepage_ == &::google::protobuf::internal::kEmptyString) {
    strhomepage_ = new ::std::string;
  }
  strhomepage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strhomepage() {
  set_has_strhomepage();
  if (strhomepage_ == &::google::protobuf::internal::kEmptyString) {
    strhomepage_ = new ::std::string;
  }
  return strhomepage_;
}
inline ::std::string* UserPrivateInfo::release_strhomepage() {
  clear_has_strhomepage();
  if (strhomepage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strhomepage_;
    strhomepage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strhomepage(::std::string* strhomepage) {
  if (strhomepage_ != &::google::protobuf::internal::kEmptyString) {
    delete strhomepage_;
  }
  if (strhomepage) {
    set_has_strhomepage();
    strhomepage_ = strhomepage;
  } else {
    clear_has_strhomepage();
    strhomepage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strPersonal = 15;
inline bool UserPrivateInfo::has_strpersonal() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserPrivateInfo::set_has_strpersonal() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserPrivateInfo::clear_has_strpersonal() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserPrivateInfo::clear_strpersonal() {
  if (strpersonal_ != &::google::protobuf::internal::kEmptyString) {
    strpersonal_->clear();
  }
  clear_has_strpersonal();
}
inline const ::std::string& UserPrivateInfo::strpersonal() const {
  return *strpersonal_;
}
inline void UserPrivateInfo::set_strpersonal(const ::std::string& value) {
  set_has_strpersonal();
  if (strpersonal_ == &::google::protobuf::internal::kEmptyString) {
    strpersonal_ = new ::std::string;
  }
  strpersonal_->assign(value);
}
inline void UserPrivateInfo::set_strpersonal(const char* value) {
  set_has_strpersonal();
  if (strpersonal_ == &::google::protobuf::internal::kEmptyString) {
    strpersonal_ = new ::std::string;
  }
  strpersonal_->assign(value);
}
inline void UserPrivateInfo::set_strpersonal(const void* value, size_t size) {
  set_has_strpersonal();
  if (strpersonal_ == &::google::protobuf::internal::kEmptyString) {
    strpersonal_ = new ::std::string;
  }
  strpersonal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strpersonal() {
  set_has_strpersonal();
  if (strpersonal_ == &::google::protobuf::internal::kEmptyString) {
    strpersonal_ = new ::std::string;
  }
  return strpersonal_;
}
inline ::std::string* UserPrivateInfo::release_strpersonal() {
  clear_has_strpersonal();
  if (strpersonal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpersonal_;
    strpersonal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strpersonal(::std::string* strpersonal) {
  if (strpersonal_ != &::google::protobuf::internal::kEmptyString) {
    delete strpersonal_;
  }
  if (strpersonal) {
    set_has_strpersonal();
    strpersonal_ = strpersonal;
  } else {
    clear_has_strpersonal();
    strpersonal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 nShengXiao = 16;
inline bool UserPrivateInfo::has_nshengxiao() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserPrivateInfo::set_has_nshengxiao() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserPrivateInfo::clear_has_nshengxiao() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserPrivateInfo::clear_nshengxiao() {
  nshengxiao_ = 0u;
  clear_has_nshengxiao();
}
inline ::google::protobuf::uint32 UserPrivateInfo::nshengxiao() const {
  return nshengxiao_;
}
inline void UserPrivateInfo::set_nshengxiao(::google::protobuf::uint32 value) {
  set_has_nshengxiao();
  nshengxiao_ = value;
}

// optional uint32 nConstel = 17;
inline bool UserPrivateInfo::has_nconstel() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserPrivateInfo::set_has_nconstel() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserPrivateInfo::clear_has_nconstel() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserPrivateInfo::clear_nconstel() {
  nconstel_ = 0u;
  clear_has_nconstel();
}
inline ::google::protobuf::uint32 UserPrivateInfo::nconstel() const {
  return nconstel_;
}
inline void UserPrivateInfo::set_nconstel(::google::protobuf::uint32 value) {
  set_has_nconstel();
  nconstel_ = value;
}

// optional uint32 nBlood = 18;
inline bool UserPrivateInfo::has_nblood() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UserPrivateInfo::set_has_nblood() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UserPrivateInfo::clear_has_nblood() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UserPrivateInfo::clear_nblood() {
  nblood_ = 0u;
  clear_has_nblood();
}
inline ::google::protobuf::uint32 UserPrivateInfo::nblood() const {
  return nblood_;
}
inline void UserPrivateInfo::set_nblood(::google::protobuf::uint32 value) {
  set_has_nblood();
  nblood_ = value;
}

// optional bytes strCustomFace = 19;
inline bool UserPrivateInfo::has_strcustomface() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UserPrivateInfo::set_has_strcustomface() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UserPrivateInfo::clear_has_strcustomface() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UserPrivateInfo::clear_strcustomface() {
  if (strcustomface_ != &::google::protobuf::internal::kEmptyString) {
    strcustomface_->clear();
  }
  clear_has_strcustomface();
}
inline const ::std::string& UserPrivateInfo::strcustomface() const {
  return *strcustomface_;
}
inline void UserPrivateInfo::set_strcustomface(const ::std::string& value) {
  set_has_strcustomface();
  if (strcustomface_ == &::google::protobuf::internal::kEmptyString) {
    strcustomface_ = new ::std::string;
  }
  strcustomface_->assign(value);
}
inline void UserPrivateInfo::set_strcustomface(const char* value) {
  set_has_strcustomface();
  if (strcustomface_ == &::google::protobuf::internal::kEmptyString) {
    strcustomface_ = new ::std::string;
  }
  strcustomface_->assign(value);
}
inline void UserPrivateInfo::set_strcustomface(const void* value, size_t size) {
  set_has_strcustomface();
  if (strcustomface_ == &::google::protobuf::internal::kEmptyString) {
    strcustomface_ = new ::std::string;
  }
  strcustomface_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPrivateInfo::mutable_strcustomface() {
  set_has_strcustomface();
  if (strcustomface_ == &::google::protobuf::internal::kEmptyString) {
    strcustomface_ = new ::std::string;
  }
  return strcustomface_;
}
inline ::std::string* UserPrivateInfo::release_strcustomface() {
  clear_has_strcustomface();
  if (strcustomface_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcustomface_;
    strcustomface_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPrivateInfo::set_allocated_strcustomface(::std::string* strcustomface) {
  if (strcustomface_ != &::google::protobuf::internal::kEmptyString) {
    delete strcustomface_;
  }
  if (strcustomface) {
    set_has_strcustomface();
    strcustomface_ = strcustomface;
  } else {
    clear_has_strcustomface();
    strcustomface_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserInfo

// required .tms.TargetInfo TargetInfos = 2;
inline bool UserInfo::has_targetinfos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_targetinfos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_targetinfos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_targetinfos() {
  if (targetinfos_ != NULL) targetinfos_->::tms::TargetInfo::Clear();
  clear_has_targetinfos();
}
inline const ::tms::TargetInfo& UserInfo::targetinfos() const {
  return targetinfos_ != NULL ? *targetinfos_ : *default_instance_->targetinfos_;
}
inline ::tms::TargetInfo* UserInfo::mutable_targetinfos() {
  set_has_targetinfos();
  if (targetinfos_ == NULL) targetinfos_ = new ::tms::TargetInfo;
  return targetinfos_;
}
inline ::tms::TargetInfo* UserInfo::release_targetinfos() {
  clear_has_targetinfos();
  ::tms::TargetInfo* temp = targetinfos_;
  targetinfos_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_targetinfos(::tms::TargetInfo* targetinfos) {
  delete targetinfos_;
  targetinfos_ = targetinfos;
  if (targetinfos) {
    set_has_targetinfos();
  } else {
    clear_has_targetinfos();
  }
}

// optional .tms.UserPrivateInfo PrivateInfos = 3;
inline bool UserInfo::has_privateinfos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_privateinfos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_privateinfos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_privateinfos() {
  if (privateinfos_ != NULL) privateinfos_->::tms::UserPrivateInfo::Clear();
  clear_has_privateinfos();
}
inline const ::tms::UserPrivateInfo& UserInfo::privateinfos() const {
  return privateinfos_ != NULL ? *privateinfos_ : *default_instance_->privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfo::mutable_privateinfos() {
  set_has_privateinfos();
  if (privateinfos_ == NULL) privateinfos_ = new ::tms::UserPrivateInfo;
  return privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfo::release_privateinfos() {
  clear_has_privateinfos();
  ::tms::UserPrivateInfo* temp = privateinfos_;
  privateinfos_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos) {
  delete privateinfos_;
  privateinfos_ = privateinfos;
  if (privateinfos) {
    set_has_privateinfos();
  } else {
    clear_has_privateinfos();
  }
}

// -------------------------------------------------------------------

// UserInfo_Old

// required .tms.TargetInfo TargetInfos = 1;
inline bool UserInfo_Old::has_targetinfos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo_Old::set_has_targetinfos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo_Old::clear_has_targetinfos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo_Old::clear_targetinfos() {
  if (targetinfos_ != NULL) targetinfos_->::tms::TargetInfo::Clear();
  clear_has_targetinfos();
}
inline const ::tms::TargetInfo& UserInfo_Old::targetinfos() const {
  return targetinfos_ != NULL ? *targetinfos_ : *default_instance_->targetinfos_;
}
inline ::tms::TargetInfo* UserInfo_Old::mutable_targetinfos() {
  set_has_targetinfos();
  if (targetinfos_ == NULL) targetinfos_ = new ::tms::TargetInfo;
  return targetinfos_;
}
inline ::tms::TargetInfo* UserInfo_Old::release_targetinfos() {
  clear_has_targetinfos();
  ::tms::TargetInfo* temp = targetinfos_;
  targetinfos_ = NULL;
  return temp;
}
inline void UserInfo_Old::set_allocated_targetinfos(::tms::TargetInfo* targetinfos) {
  delete targetinfos_;
  targetinfos_ = targetinfos;
  if (targetinfos) {
    set_has_targetinfos();
  } else {
    clear_has_targetinfos();
  }
}

// optional .tms.UserPrivateInfo PrivateInfos = 2;
inline bool UserInfo_Old::has_privateinfos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo_Old::set_has_privateinfos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo_Old::clear_has_privateinfos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo_Old::clear_privateinfos() {
  if (privateinfos_ != NULL) privateinfos_->::tms::UserPrivateInfo::Clear();
  clear_has_privateinfos();
}
inline const ::tms::UserPrivateInfo& UserInfo_Old::privateinfos() const {
  return privateinfos_ != NULL ? *privateinfos_ : *default_instance_->privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfo_Old::mutable_privateinfos() {
  set_has_privateinfos();
  if (privateinfos_ == NULL) privateinfos_ = new ::tms::UserPrivateInfo;
  return privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfo_Old::release_privateinfos() {
  clear_has_privateinfos();
  ::tms::UserPrivateInfo* temp = privateinfos_;
  privateinfos_ = NULL;
  return temp;
}
inline void UserInfo_Old::set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos) {
  delete privateinfos_;
  privateinfos_ = privateinfos;
  if (privateinfos) {
    set_has_privateinfos();
  } else {
    clear_has_privateinfos();
  }
}

// optional .tms.TargetsNotify TargetsNotifys = 3;
inline bool UserInfo_Old::has_targetsnotifys() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo_Old::set_has_targetsnotifys() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo_Old::clear_has_targetsnotifys() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo_Old::clear_targetsnotifys() {
  if (targetsnotifys_ != NULL) targetsnotifys_->::tms::TargetsNotify::Clear();
  clear_has_targetsnotifys();
}
inline const ::tms::TargetsNotify& UserInfo_Old::targetsnotifys() const {
  return targetsnotifys_ != NULL ? *targetsnotifys_ : *default_instance_->targetsnotifys_;
}
inline ::tms::TargetsNotify* UserInfo_Old::mutable_targetsnotifys() {
  set_has_targetsnotifys();
  if (targetsnotifys_ == NULL) targetsnotifys_ = new ::tms::TargetsNotify;
  return targetsnotifys_;
}
inline ::tms::TargetsNotify* UserInfo_Old::release_targetsnotifys() {
  clear_has_targetsnotifys();
  ::tms::TargetsNotify* temp = targetsnotifys_;
  targetsnotifys_ = NULL;
  return temp;
}
inline void UserInfo_Old::set_allocated_targetsnotifys(::tms::TargetsNotify* targetsnotifys) {
  delete targetsnotifys_;
  targetsnotifys_ = targetsnotifys;
  if (targetsnotifys) {
    set_has_targetsnotifys();
  } else {
    clear_has_targetsnotifys();
  }
}

// -------------------------------------------------------------------

// UserOnlineInfo

// required uint32 uAccountID = 1 [default = 0];
inline bool UserOnlineInfo::has_uaccountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOnlineInfo::set_has_uaccountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOnlineInfo::clear_has_uaccountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOnlineInfo::clear_uaccountid() {
  uaccountid_ = 0u;
  clear_has_uaccountid();
}
inline ::google::protobuf::uint32 UserOnlineInfo::uaccountid() const {
  return uaccountid_;
}
inline void UserOnlineInfo::set_uaccountid(::google::protobuf::uint32 value) {
  set_has_uaccountid();
  uaccountid_ = value;
}

// required uint32 uLoginFlag = 2 [default = 0];
inline bool UserOnlineInfo::has_uloginflag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserOnlineInfo::set_has_uloginflag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserOnlineInfo::clear_has_uloginflag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserOnlineInfo::clear_uloginflag() {
  uloginflag_ = 0u;
  clear_has_uloginflag();
}
inline ::google::protobuf::uint32 UserOnlineInfo::uloginflag() const {
  return uloginflag_;
}
inline void UserOnlineInfo::set_uloginflag(::google::protobuf::uint32 value) {
  set_has_uloginflag();
  uloginflag_ = value;
}

// -------------------------------------------------------------------

// LoginInfo

// required string strAccountNo = 1;
inline bool LoginInfo::has_straccountno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginInfo::set_has_straccountno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginInfo::clear_has_straccountno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginInfo::clear_straccountno() {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    straccountno_->clear();
  }
  clear_has_straccountno();
}
inline const ::std::string& LoginInfo::straccountno() const {
  return *straccountno_;
}
inline void LoginInfo::set_straccountno(const ::std::string& value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void LoginInfo::set_straccountno(const char* value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void LoginInfo::set_straccountno(const char* value, size_t size) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInfo::mutable_straccountno() {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  return straccountno_;
}
inline ::std::string* LoginInfo::release_straccountno() {
  clear_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccountno_;
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginInfo::set_allocated_straccountno(::std::string* straccountno) {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    delete straccountno_;
  }
  if (straccountno) {
    set_has_straccountno();
    straccountno_ = straccountno;
  } else {
    clear_has_straccountno();
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPasswd = 2;
inline bool LoginInfo::has_strpasswd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginInfo::set_has_strpasswd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginInfo::clear_has_strpasswd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginInfo::clear_strpasswd() {
  if (strpasswd_ != &::google::protobuf::internal::kEmptyString) {
    strpasswd_->clear();
  }
  clear_has_strpasswd();
}
inline const ::std::string& LoginInfo::strpasswd() const {
  return *strpasswd_;
}
inline void LoginInfo::set_strpasswd(const ::std::string& value) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(value);
}
inline void LoginInfo::set_strpasswd(const char* value) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(value);
}
inline void LoginInfo::set_strpasswd(const char* value, size_t size) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInfo::mutable_strpasswd() {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  return strpasswd_;
}
inline ::std::string* LoginInfo::release_strpasswd() {
  clear_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpasswd_;
    strpasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginInfo::set_allocated_strpasswd(::std::string* strpasswd) {
  if (strpasswd_ != &::google::protobuf::internal::kEmptyString) {
    delete strpasswd_;
  }
  if (strpasswd) {
    set_has_strpasswd();
    strpasswd_ = strpasswd;
  } else {
    clear_has_strpasswd();
    strpasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 uLoginFlags = 3 [default = 0];
inline bool LoginInfo::has_uloginflags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginInfo::set_has_uloginflags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginInfo::clear_has_uloginflags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginInfo::clear_uloginflags() {
  uloginflags_ = 0u;
  clear_has_uloginflags();
}
inline ::google::protobuf::uint32 LoginInfo::uloginflags() const {
  return uloginflags_;
}
inline void LoginInfo::set_uloginflags(::google::protobuf::uint32 value) {
  set_has_uloginflags();
  uloginflags_ = value;
}

// -------------------------------------------------------------------

// LoginAnsInfo

// required uint32 uAccountID = 1;
inline bool LoginAnsInfo::has_uaccountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAnsInfo::set_has_uaccountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAnsInfo::clear_has_uaccountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAnsInfo::clear_uaccountid() {
  uaccountid_ = 0u;
  clear_has_uaccountid();
}
inline ::google::protobuf::uint32 LoginAnsInfo::uaccountid() const {
  return uaccountid_;
}
inline void LoginAnsInfo::set_uaccountid(::google::protobuf::uint32 value) {
  set_has_uaccountid();
  uaccountid_ = value;
}

// required uint32 uSessionID = 2;
inline bool LoginAnsInfo::has_usessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginAnsInfo::set_has_usessionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginAnsInfo::clear_has_usessionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginAnsInfo::clear_usessionid() {
  usessionid_ = 0u;
  clear_has_usessionid();
}
inline ::google::protobuf::uint32 LoginAnsInfo::usessionid() const {
  return usessionid_;
}
inline void LoginAnsInfo::set_usessionid(::google::protobuf::uint32 value) {
  set_has_usessionid();
  usessionid_ = value;
}

// required uint32 nClientType = 3 [default = 0];
inline bool LoginAnsInfo::has_nclienttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginAnsInfo::set_has_nclienttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginAnsInfo::clear_has_nclienttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginAnsInfo::clear_nclienttype() {
  nclienttype_ = 0u;
  clear_has_nclienttype();
}
inline ::google::protobuf::uint32 LoginAnsInfo::nclienttype() const {
  return nclienttype_;
}
inline void LoginAnsInfo::set_nclienttype(::google::protobuf::uint32 value) {
  set_has_nclienttype();
  nclienttype_ = value;
}

// -------------------------------------------------------------------

// RegisterInfo

// required string strAccountNo = 1;
inline bool RegisterInfo::has_straccountno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterInfo::set_has_straccountno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterInfo::clear_has_straccountno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterInfo::clear_straccountno() {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    straccountno_->clear();
  }
  clear_has_straccountno();
}
inline const ::std::string& RegisterInfo::straccountno() const {
  return *straccountno_;
}
inline void RegisterInfo::set_straccountno(const ::std::string& value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void RegisterInfo::set_straccountno(const char* value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void RegisterInfo::set_straccountno(const char* value, size_t size) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInfo::mutable_straccountno() {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  return straccountno_;
}
inline ::std::string* RegisterInfo::release_straccountno() {
  clear_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccountno_;
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInfo::set_allocated_straccountno(::std::string* straccountno) {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    delete straccountno_;
  }
  if (straccountno) {
    set_has_straccountno();
    straccountno_ = straccountno;
  } else {
    clear_has_straccountno();
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string strPasswd = 2;
inline bool RegisterInfo::has_strpasswd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterInfo::set_has_strpasswd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterInfo::clear_has_strpasswd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterInfo::clear_strpasswd() {
  if (strpasswd_ != &::google::protobuf::internal::kEmptyString) {
    strpasswd_->clear();
  }
  clear_has_strpasswd();
}
inline const ::std::string& RegisterInfo::strpasswd() const {
  return *strpasswd_;
}
inline void RegisterInfo::set_strpasswd(const ::std::string& value) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(value);
}
inline void RegisterInfo::set_strpasswd(const char* value) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(value);
}
inline void RegisterInfo::set_strpasswd(const char* value, size_t size) {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  strpasswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInfo::mutable_strpasswd() {
  set_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    strpasswd_ = new ::std::string;
  }
  return strpasswd_;
}
inline ::std::string* RegisterInfo::release_strpasswd() {
  clear_has_strpasswd();
  if (strpasswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpasswd_;
    strpasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInfo::set_allocated_strpasswd(::std::string* strpasswd) {
  if (strpasswd_ != &::google::protobuf::internal::kEmptyString) {
    delete strpasswd_;
  }
  if (strpasswd) {
    set_has_strpasswd();
    strpasswd_ = strpasswd;
  } else {
    clear_has_strpasswd();
    strpasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes strNickName = 3;
inline bool RegisterInfo::has_strnickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterInfo::set_has_strnickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterInfo::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterInfo::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& RegisterInfo::strnickname() const {
  return *strnickname_;
}
inline void RegisterInfo::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void RegisterInfo::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void RegisterInfo::set_strnickname(const void* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterInfo::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* RegisterInfo::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterInfo::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserInfoReq

// required .tms.UserInfoReq.cmd ncmd = 1 [default = UserInfo];
inline bool UserInfoReq::has_ncmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoReq::set_has_ncmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoReq::clear_has_ncmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoReq::clear_ncmd() {
  ncmd_ = 3;
  clear_has_ncmd();
}
inline ::tms::UserInfoReq_cmd UserInfoReq::ncmd() const {
  return static_cast< ::tms::UserInfoReq_cmd >(ncmd_);
}
inline void UserInfoReq::set_ncmd(::tms::UserInfoReq_cmd value) {
  assert(::tms::UserInfoReq_cmd_IsValid(value));
  set_has_ncmd();
  ncmd_ = value;
}

// -------------------------------------------------------------------

// TargetsQuery

// required string strAccountNo = 1;
inline bool TargetsQuery::has_straccountno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetsQuery::set_has_straccountno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetsQuery::clear_has_straccountno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetsQuery::clear_straccountno() {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    straccountno_->clear();
  }
  clear_has_straccountno();
}
inline const ::std::string& TargetsQuery::straccountno() const {
  return *straccountno_;
}
inline void TargetsQuery::set_straccountno(const ::std::string& value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void TargetsQuery::set_straccountno(const char* value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void TargetsQuery::set_straccountno(const char* value, size_t size) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetsQuery::mutable_straccountno() {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  return straccountno_;
}
inline ::std::string* TargetsQuery::release_straccountno() {
  clear_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccountno_;
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetsQuery::set_allocated_straccountno(::std::string* straccountno) {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    delete straccountno_;
  }
  if (straccountno) {
    set_has_straccountno();
    straccountno_ = straccountno;
  } else {
    clear_has_straccountno();
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes strNickName = 2;
inline bool TargetsQuery::has_strnickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetsQuery::set_has_strnickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetsQuery::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetsQuery::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& TargetsQuery::strnickname() const {
  return *strnickname_;
}
inline void TargetsQuery::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void TargetsQuery::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void TargetsQuery::set_strnickname(const void* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TargetsQuery::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* TargetsQuery::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TargetsQuery::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UpdateUserInfo

// optional bytes strNickName = 1;
inline bool UpdateUserInfo::has_strnickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserInfo::set_has_strnickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserInfo::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserInfo::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& UpdateUserInfo::strnickname() const {
  return *strnickname_;
}
inline void UpdateUserInfo::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UpdateUserInfo::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UpdateUserInfo::set_strnickname(const void* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateUserInfo::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* UpdateUserInfo::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateUserInfo::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 nFace = 2 [default = 0];
inline bool UpdateUserInfo::has_nface() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateUserInfo::set_has_nface() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateUserInfo::clear_has_nface() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateUserInfo::clear_nface() {
  nface_ = 0u;
  clear_has_nface();
}
inline ::google::protobuf::uint32 UpdateUserInfo::nface() const {
  return nface_;
}
inline void UpdateUserInfo::set_nface(::google::protobuf::uint32 value) {
  set_has_nface();
  nface_ = value;
}

// optional .tms.UserPrivateInfo PrivateInfos = 3;
inline bool UpdateUserInfo::has_privateinfos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateUserInfo::set_has_privateinfos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateUserInfo::clear_has_privateinfos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateUserInfo::clear_privateinfos() {
  if (privateinfos_ != NULL) privateinfos_->::tms::UserPrivateInfo::Clear();
  clear_has_privateinfos();
}
inline const ::tms::UserPrivateInfo& UpdateUserInfo::privateinfos() const {
  return privateinfos_ != NULL ? *privateinfos_ : *default_instance_->privateinfos_;
}
inline ::tms::UserPrivateInfo* UpdateUserInfo::mutable_privateinfos() {
  set_has_privateinfos();
  if (privateinfos_ == NULL) privateinfos_ = new ::tms::UserPrivateInfo;
  return privateinfos_;
}
inline ::tms::UserPrivateInfo* UpdateUserInfo::release_privateinfos() {
  clear_has_privateinfos();
  ::tms::UserPrivateInfo* temp = privateinfos_;
  privateinfos_ = NULL;
  return temp;
}
inline void UpdateUserInfo::set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos) {
  delete privateinfos_;
  privateinfos_ = privateinfos;
  if (privateinfos) {
    set_has_privateinfos();
  } else {
    clear_has_privateinfos();
  }
}

// -------------------------------------------------------------------

// TargetsAdd

// required uint32 uTargetID = 1 [default = 0];
inline bool TargetsAdd::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetsAdd::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetsAdd::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetsAdd::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 TargetsAdd::utargetid() const {
  return utargetid_;
}
inline void TargetsAdd::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// required .tms.TargetsAdd.cmd ncmd = 2 [default = Apply];
inline bool TargetsAdd::has_ncmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetsAdd::set_has_ncmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetsAdd::clear_has_ncmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetsAdd::clear_ncmd() {
  ncmd_ = 0;
  clear_has_ncmd();
}
inline ::tms::TargetsAdd_cmd TargetsAdd::ncmd() const {
  return static_cast< ::tms::TargetsAdd_cmd >(ncmd_);
}
inline void TargetsAdd::set_ncmd(::tms::TargetsAdd_cmd value) {
  assert(::tms::TargetsAdd_cmd_IsValid(value));
  set_has_ncmd();
  ncmd_ = value;
}

// -------------------------------------------------------------------

// UpdateTargetInfo

// required uint32 uTargetID = 1 [default = 0];
inline bool UpdateTargetInfo::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTargetInfo::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTargetInfo::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTargetInfo::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 UpdateTargetInfo::utargetid() const {
  return utargetid_;
}
inline void UpdateTargetInfo::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// optional bytes strNickName = 2;
inline bool UpdateTargetInfo::has_strnickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTargetInfo::set_has_strnickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTargetInfo::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTargetInfo::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& UpdateTargetInfo::strnickname() const {
  return *strnickname_;
}
inline void UpdateTargetInfo::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UpdateTargetInfo::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UpdateTargetInfo::set_strnickname(const void* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateTargetInfo::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* UpdateTargetInfo::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateTargetInfo::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes selfparam = 3;
inline bool UpdateTargetInfo::has_selfparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateTargetInfo::set_has_selfparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateTargetInfo::clear_has_selfparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateTargetInfo::clear_selfparam() {
  if (selfparam_ != &::google::protobuf::internal::kEmptyString) {
    selfparam_->clear();
  }
  clear_has_selfparam();
}
inline const ::std::string& UpdateTargetInfo::selfparam() const {
  return *selfparam_;
}
inline void UpdateTargetInfo::set_selfparam(const ::std::string& value) {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  selfparam_->assign(value);
}
inline void UpdateTargetInfo::set_selfparam(const char* value) {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  selfparam_->assign(value);
}
inline void UpdateTargetInfo::set_selfparam(const void* value, size_t size) {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  selfparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateTargetInfo::mutable_selfparam() {
  set_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    selfparam_ = new ::std::string;
  }
  return selfparam_;
}
inline ::std::string* UpdateTargetInfo::release_selfparam() {
  clear_has_selfparam();
  if (selfparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfparam_;
    selfparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateTargetInfo::set_allocated_selfparam(::std::string* selfparam) {
  if (selfparam_ != &::google::protobuf::internal::kEmptyString) {
    delete selfparam_;
  }
  if (selfparam) {
    set_has_selfparam();
    selfparam_ = selfparam;
  } else {
    clear_has_selfparam();
    selfparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserInfoNotify

// required uint32 uAccountID = 1 [default = 0];
inline bool UserInfoNotify::has_uaccountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoNotify::set_has_uaccountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoNotify::clear_has_uaccountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoNotify::clear_uaccountid() {
  uaccountid_ = 0u;
  clear_has_uaccountid();
}
inline ::google::protobuf::uint32 UserInfoNotify::uaccountid() const {
  return uaccountid_;
}
inline void UserInfoNotify::set_uaccountid(::google::protobuf::uint32 value) {
  set_has_uaccountid();
  uaccountid_ = value;
}

// optional string strAccountNo = 2;
inline bool UserInfoNotify::has_straccountno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoNotify::set_has_straccountno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoNotify::clear_has_straccountno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoNotify::clear_straccountno() {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    straccountno_->clear();
  }
  clear_has_straccountno();
}
inline const ::std::string& UserInfoNotify::straccountno() const {
  return *straccountno_;
}
inline void UserInfoNotify::set_straccountno(const ::std::string& value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void UserInfoNotify::set_straccountno(const char* value) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(value);
}
inline void UserInfoNotify::set_straccountno(const char* value, size_t size) {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  straccountno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoNotify::mutable_straccountno() {
  set_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    straccountno_ = new ::std::string;
  }
  return straccountno_;
}
inline ::std::string* UserInfoNotify::release_straccountno() {
  clear_has_straccountno();
  if (straccountno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccountno_;
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoNotify::set_allocated_straccountno(::std::string* straccountno) {
  if (straccountno_ != &::google::protobuf::internal::kEmptyString) {
    delete straccountno_;
  }
  if (straccountno) {
    set_has_straccountno();
    straccountno_ = straccountno;
  } else {
    clear_has_straccountno();
    straccountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes strNickName = 3;
inline bool UserInfoNotify::has_strnickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfoNotify::set_has_strnickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfoNotify::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfoNotify::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& UserInfoNotify::strnickname() const {
  return *strnickname_;
}
inline void UserInfoNotify::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UserInfoNotify::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void UserInfoNotify::set_strnickname(const void* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoNotify::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* UserInfoNotify::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoNotify::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 nFace = 4 [default = 0];
inline bool UserInfoNotify::has_nface() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfoNotify::set_has_nface() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfoNotify::clear_has_nface() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfoNotify::clear_nface() {
  nface_ = 0u;
  clear_has_nface();
}
inline ::google::protobuf::uint32 UserInfoNotify::nface() const {
  return nface_;
}
inline void UserInfoNotify::set_nface(::google::protobuf::uint32 value) {
  set_has_nface();
  nface_ = value;
}

// optional .tms.UserPrivateInfo PrivateInfos = 5;
inline bool UserInfoNotify::has_privateinfos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfoNotify::set_has_privateinfos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfoNotify::clear_has_privateinfos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfoNotify::clear_privateinfos() {
  if (privateinfos_ != NULL) privateinfos_->::tms::UserPrivateInfo::Clear();
  clear_has_privateinfos();
}
inline const ::tms::UserPrivateInfo& UserInfoNotify::privateinfos() const {
  return privateinfos_ != NULL ? *privateinfos_ : *default_instance_->privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfoNotify::mutable_privateinfos() {
  set_has_privateinfos();
  if (privateinfos_ == NULL) privateinfos_ = new ::tms::UserPrivateInfo;
  return privateinfos_;
}
inline ::tms::UserPrivateInfo* UserInfoNotify::release_privateinfos() {
  clear_has_privateinfos();
  ::tms::UserPrivateInfo* temp = privateinfos_;
  privateinfos_ = NULL;
  return temp;
}
inline void UserInfoNotify::set_allocated_privateinfos(::tms::UserPrivateInfo* privateinfos) {
  delete privateinfos_;
  privateinfos_ = privateinfos;
  if (privateinfos) {
    set_has_privateinfos();
  } else {
    clear_has_privateinfos();
  }
}

// -------------------------------------------------------------------

// TargetsAddNotify

// required .tms.TargetsAdd TargetsAdds = 1;
inline bool TargetsAddNotify::has_targetsadds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetsAddNotify::set_has_targetsadds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetsAddNotify::clear_has_targetsadds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetsAddNotify::clear_targetsadds() {
  if (targetsadds_ != NULL) targetsadds_->::tms::TargetsAdd::Clear();
  clear_has_targetsadds();
}
inline const ::tms::TargetsAdd& TargetsAddNotify::targetsadds() const {
  return targetsadds_ != NULL ? *targetsadds_ : *default_instance_->targetsadds_;
}
inline ::tms::TargetsAdd* TargetsAddNotify::mutable_targetsadds() {
  set_has_targetsadds();
  if (targetsadds_ == NULL) targetsadds_ = new ::tms::TargetsAdd;
  return targetsadds_;
}
inline ::tms::TargetsAdd* TargetsAddNotify::release_targetsadds() {
  clear_has_targetsadds();
  ::tms::TargetsAdd* temp = targetsadds_;
  targetsadds_ = NULL;
  return temp;
}
inline void TargetsAddNotify::set_allocated_targetsadds(::tms::TargetsAdd* targetsadds) {
  delete targetsadds_;
  targetsadds_ = targetsadds;
  if (targetsadds) {
    set_has_targetsadds();
  } else {
    clear_has_targetsadds();
  }
}

// required .tms.TargetInfo TargetInfos = 3;
inline bool TargetsAddNotify::has_targetinfos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetsAddNotify::set_has_targetinfos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetsAddNotify::clear_has_targetinfos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetsAddNotify::clear_targetinfos() {
  if (targetinfos_ != NULL) targetinfos_->::tms::TargetInfo::Clear();
  clear_has_targetinfos();
}
inline const ::tms::TargetInfo& TargetsAddNotify::targetinfos() const {
  return targetinfos_ != NULL ? *targetinfos_ : *default_instance_->targetinfos_;
}
inline ::tms::TargetInfo* TargetsAddNotify::mutable_targetinfos() {
  set_has_targetinfos();
  if (targetinfos_ == NULL) targetinfos_ = new ::tms::TargetInfo;
  return targetinfos_;
}
inline ::tms::TargetInfo* TargetsAddNotify::release_targetinfos() {
  clear_has_targetinfos();
  ::tms::TargetInfo* temp = targetinfos_;
  targetinfos_ = NULL;
  return temp;
}
inline void TargetsAddNotify::set_allocated_targetinfos(::tms::TargetInfo* targetinfos) {
  delete targetinfos_;
  targetinfos_ = targetinfos;
  if (targetinfos) {
    set_has_targetinfos();
  } else {
    clear_has_targetinfos();
  }
}

// -------------------------------------------------------------------

// TargetsNotify

// repeated .tms.Targets Targetss = 1;
inline int TargetsNotify::targetss_size() const {
  return targetss_.size();
}
inline void TargetsNotify::clear_targetss() {
  targetss_.Clear();
}
inline const ::tms::Targets& TargetsNotify::targetss(int index) const {
  return targetss_.Get(index);
}
inline ::tms::Targets* TargetsNotify::mutable_targetss(int index) {
  return targetss_.Mutable(index);
}
inline ::tms::Targets* TargetsNotify::add_targetss() {
  return targetss_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::Targets >&
TargetsNotify::targetss() const {
  return targetss_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::Targets >*
TargetsNotify::mutable_targetss() {
  return &targetss_;
}

// -------------------------------------------------------------------

// ServerTime

// required uint64 uServerTime = 1;
inline bool ServerTime::has_uservertime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerTime::set_has_uservertime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerTime::clear_has_uservertime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerTime::clear_uservertime() {
  uservertime_ = GOOGLE_ULONGLONG(0);
  clear_has_uservertime();
}
inline ::google::protobuf::uint64 ServerTime::uservertime() const {
  return uservertime_;
}
inline void ServerTime::set_uservertime(::google::protobuf::uint64 value) {
  set_has_uservertime();
  uservertime_ = value;
}

// -------------------------------------------------------------------

// FileLoadInfo

// required bytes strName = 1;
inline bool FileLoadInfo::has_strname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileLoadInfo::set_has_strname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileLoadInfo::clear_has_strname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileLoadInfo::clear_strname() {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    strname_->clear();
  }
  clear_has_strname();
}
inline const ::std::string& FileLoadInfo::strname() const {
  return *strname_;
}
inline void FileLoadInfo::set_strname(const ::std::string& value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void FileLoadInfo::set_strname(const char* value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void FileLoadInfo::set_strname(const void* value, size_t size) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLoadInfo::mutable_strname() {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  return strname_;
}
inline ::std::string* FileLoadInfo::release_strname() {
  clear_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strname_;
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLoadInfo::set_allocated_strname(::std::string* strname) {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    delete strname_;
  }
  if (strname) {
    set_has_strname();
    strname_ = strname;
  } else {
    clear_has_strname();
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 uOffset = 2;
inline bool FileLoadInfo::has_uoffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileLoadInfo::set_has_uoffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileLoadInfo::clear_has_uoffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileLoadInfo::clear_uoffset() {
  uoffset_ = 0u;
  clear_has_uoffset();
}
inline ::google::protobuf::uint32 FileLoadInfo::uoffset() const {
  return uoffset_;
}
inline void FileLoadInfo::set_uoffset(::google::protobuf::uint32 value) {
  set_has_uoffset();
  uoffset_ = value;
}

// required uint32 uDownsize = 3;
inline bool FileLoadInfo::has_udownsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileLoadInfo::set_has_udownsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileLoadInfo::clear_has_udownsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileLoadInfo::clear_udownsize() {
  udownsize_ = 0u;
  clear_has_udownsize();
}
inline ::google::protobuf::uint32 FileLoadInfo::udownsize() const {
  return udownsize_;
}
inline void FileLoadInfo::set_udownsize(::google::protobuf::uint32 value) {
  set_has_udownsize();
  udownsize_ = value;
}

// required uint32 uLocalsize = 4;
inline bool FileLoadInfo::has_ulocalsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileLoadInfo::set_has_ulocalsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileLoadInfo::clear_has_ulocalsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileLoadInfo::clear_ulocalsize() {
  ulocalsize_ = 0u;
  clear_has_ulocalsize();
}
inline ::google::protobuf::uint32 FileLoadInfo::ulocalsize() const {
  return ulocalsize_;
}
inline void FileLoadInfo::set_ulocalsize(::google::protobuf::uint32 value) {
  set_has_ulocalsize();
  ulocalsize_ = value;
}

// required uint32 uLocaltime = 5;
inline bool FileLoadInfo::has_ulocaltime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileLoadInfo::set_has_ulocaltime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileLoadInfo::clear_has_ulocaltime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileLoadInfo::clear_ulocaltime() {
  ulocaltime_ = 0u;
  clear_has_ulocaltime();
}
inline ::google::protobuf::uint32 FileLoadInfo::ulocaltime() const {
  return ulocaltime_;
}
inline void FileLoadInfo::set_ulocaltime(::google::protobuf::uint32 value) {
  set_has_ulocaltime();
  ulocaltime_ = value;
}

// required uint32 bVersion = 6;
inline bool FileLoadInfo::has_bversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileLoadInfo::set_has_bversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileLoadInfo::clear_has_bversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileLoadInfo::clear_bversion() {
  bversion_ = 0u;
  clear_has_bversion();
}
inline ::google::protobuf::uint32 FileLoadInfo::bversion() const {
  return bversion_;
}
inline void FileLoadInfo::set_bversion(::google::protobuf::uint32 value) {
  set_has_bversion();
  bversion_ = value;
}

// -------------------------------------------------------------------

// FileLoadData

// required uint32 uError = 1;
inline bool FileLoadData::has_uerror() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileLoadData::set_has_uerror() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileLoadData::clear_has_uerror() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileLoadData::clear_uerror() {
  uerror_ = 0u;
  clear_has_uerror();
}
inline ::google::protobuf::uint32 FileLoadData::uerror() const {
  return uerror_;
}
inline void FileLoadData::set_uerror(::google::protobuf::uint32 value) {
  set_has_uerror();
  uerror_ = value;
}

// required uint32 uFilesize = 2;
inline bool FileLoadData::has_ufilesize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileLoadData::set_has_ufilesize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileLoadData::clear_has_ufilesize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileLoadData::clear_ufilesize() {
  ufilesize_ = 0u;
  clear_has_ufilesize();
}
inline ::google::protobuf::uint32 FileLoadData::ufilesize() const {
  return ufilesize_;
}
inline void FileLoadData::set_ufilesize(::google::protobuf::uint32 value) {
  set_has_ufilesize();
  ufilesize_ = value;
}

// required uint32 uOffset = 3;
inline bool FileLoadData::has_uoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileLoadData::set_has_uoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileLoadData::clear_has_uoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileLoadData::clear_uoffset() {
  uoffset_ = 0u;
  clear_has_uoffset();
}
inline ::google::protobuf::uint32 FileLoadData::uoffset() const {
  return uoffset_;
}
inline void FileLoadData::set_uoffset(::google::protobuf::uint32 value) {
  set_has_uoffset();
  uoffset_ = value;
}

// required uint32 uDownsize = 4;
inline bool FileLoadData::has_udownsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileLoadData::set_has_udownsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileLoadData::clear_has_udownsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileLoadData::clear_udownsize() {
  udownsize_ = 0u;
  clear_has_udownsize();
}
inline ::google::protobuf::uint32 FileLoadData::udownsize() const {
  return udownsize_;
}
inline void FileLoadData::set_udownsize(::google::protobuf::uint32 value) {
  set_has_udownsize();
  udownsize_ = value;
}

// required uint32 uTmmodified = 5;
inline bool FileLoadData::has_utmmodified() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileLoadData::set_has_utmmodified() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileLoadData::clear_has_utmmodified() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileLoadData::clear_utmmodified() {
  utmmodified_ = 0u;
  clear_has_utmmodified();
}
inline ::google::protobuf::uint32 FileLoadData::utmmodified() const {
  return utmmodified_;
}
inline void FileLoadData::set_utmmodified(::google::protobuf::uint32 value) {
  set_has_utmmodified();
  utmmodified_ = value;
}

// optional bytes szData = 6;
inline bool FileLoadData::has_szdata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileLoadData::set_has_szdata() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileLoadData::clear_has_szdata() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileLoadData::clear_szdata() {
  if (szdata_ != &::google::protobuf::internal::kEmptyString) {
    szdata_->clear();
  }
  clear_has_szdata();
}
inline const ::std::string& FileLoadData::szdata() const {
  return *szdata_;
}
inline void FileLoadData::set_szdata(const ::std::string& value) {
  set_has_szdata();
  if (szdata_ == &::google::protobuf::internal::kEmptyString) {
    szdata_ = new ::std::string;
  }
  szdata_->assign(value);
}
inline void FileLoadData::set_szdata(const char* value) {
  set_has_szdata();
  if (szdata_ == &::google::protobuf::internal::kEmptyString) {
    szdata_ = new ::std::string;
  }
  szdata_->assign(value);
}
inline void FileLoadData::set_szdata(const void* value, size_t size) {
  set_has_szdata();
  if (szdata_ == &::google::protobuf::internal::kEmptyString) {
    szdata_ = new ::std::string;
  }
  szdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileLoadData::mutable_szdata() {
  set_has_szdata();
  if (szdata_ == &::google::protobuf::internal::kEmptyString) {
    szdata_ = new ::std::string;
  }
  return szdata_;
}
inline ::std::string* FileLoadData::release_szdata() {
  clear_has_szdata();
  if (szdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szdata_;
    szdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileLoadData::set_allocated_szdata(::std::string* szdata) {
  if (szdata_ != &::google::protobuf::internal::kEmptyString) {
    delete szdata_;
  }
  if (szdata) {
    set_has_szdata();
    szdata_ = szdata;
  } else {
    clear_has_szdata();
    szdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TalkMsg

// required uint32 uSendID = 1 [default = 0];
inline bool TalkMsg::has_usendid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TalkMsg::set_has_usendid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TalkMsg::clear_has_usendid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TalkMsg::clear_usendid() {
  usendid_ = 0u;
  clear_has_usendid();
}
inline ::google::protobuf::uint32 TalkMsg::usendid() const {
  return usendid_;
}
inline void TalkMsg::set_usendid(::google::protobuf::uint32 value) {
  set_has_usendid();
  usendid_ = value;
}

// required uint32 uTargetID = 2 [default = 0];
inline bool TalkMsg::has_utargetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TalkMsg::set_has_utargetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TalkMsg::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TalkMsg::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 TalkMsg::utargetid() const {
  return utargetid_;
}
inline void TalkMsg::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// optional uint32 uMsgID = 3 [default = 0];
inline bool TalkMsg::has_umsgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TalkMsg::set_has_umsgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TalkMsg::clear_has_umsgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TalkMsg::clear_umsgid() {
  umsgid_ = 0u;
  clear_has_umsgid();
}
inline ::google::protobuf::uint32 TalkMsg::umsgid() const {
  return umsgid_;
}
inline void TalkMsg::set_umsgid(::google::protobuf::uint32 value) {
  set_has_umsgid();
  umsgid_ = value;
}

// required bytes msg = 4;
inline bool TalkMsg::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TalkMsg::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TalkMsg::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TalkMsg::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& TalkMsg::msg() const {
  return *msg_;
}
inline void TalkMsg::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void TalkMsg::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void TalkMsg::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TalkMsg::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* TalkMsg::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TalkMsg::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TalkMsgAns

// required uint32 uError = 1 [default = 0];
inline bool TalkMsgAns::has_uerror() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TalkMsgAns::set_has_uerror() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TalkMsgAns::clear_has_uerror() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TalkMsgAns::clear_uerror() {
  uerror_ = 0u;
  clear_has_uerror();
}
inline ::google::protobuf::uint32 TalkMsgAns::uerror() const {
  return uerror_;
}
inline void TalkMsgAns::set_uerror(::google::protobuf::uint32 value) {
  set_has_uerror();
  uerror_ = value;
}

// required uint32 uTargetID = 2 [default = 0];
inline bool TalkMsgAns::has_utargetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TalkMsgAns::set_has_utargetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TalkMsgAns::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TalkMsgAns::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 TalkMsgAns::utargetid() const {
  return utargetid_;
}
inline void TalkMsgAns::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// required uint32 uMsgID = 3 [default = 0];
inline bool TalkMsgAns::has_umsgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TalkMsgAns::set_has_umsgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TalkMsgAns::clear_has_umsgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TalkMsgAns::clear_umsgid() {
  umsgid_ = 0u;
  clear_has_umsgid();
}
inline ::google::protobuf::uint32 TalkMsgAns::umsgid() const {
  return umsgid_;
}
inline void TalkMsgAns::set_umsgid(::google::protobuf::uint32 value) {
  set_has_umsgid();
  umsgid_ = value;
}

// -------------------------------------------------------------------

// TmpTalkMsg

// required uint32 uTargetID = 1 [default = 0];
inline bool TmpTalkMsg::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TmpTalkMsg::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TmpTalkMsg::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TmpTalkMsg::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 TmpTalkMsg::utargetid() const {
  return utargetid_;
}
inline void TmpTalkMsg::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// required bytes strNickName = 2;
inline bool TmpTalkMsg::has_strnickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TmpTalkMsg::set_has_strnickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TmpTalkMsg::clear_has_strnickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TmpTalkMsg::clear_strnickname() {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    strnickname_->clear();
  }
  clear_has_strnickname();
}
inline const ::std::string& TmpTalkMsg::strnickname() const {
  return *strnickname_;
}
inline void TmpTalkMsg::set_strnickname(const ::std::string& value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void TmpTalkMsg::set_strnickname(const char* value) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(value);
}
inline void TmpTalkMsg::set_strnickname(const void* value, size_t size) {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  strnickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TmpTalkMsg::mutable_strnickname() {
  set_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    strnickname_ = new ::std::string;
  }
  return strnickname_;
}
inline ::std::string* TmpTalkMsg::release_strnickname() {
  clear_has_strnickname();
  if (strnickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnickname_;
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TmpTalkMsg::set_allocated_strnickname(::std::string* strnickname) {
  if (strnickname_ != &::google::protobuf::internal::kEmptyString) {
    delete strnickname_;
  }
  if (strnickname) {
    set_has_strnickname();
    strnickname_ = strnickname;
  } else {
    clear_has_strnickname();
    strnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 uMsgID = 3 [default = 0];
inline bool TmpTalkMsg::has_umsgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TmpTalkMsg::set_has_umsgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TmpTalkMsg::clear_has_umsgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TmpTalkMsg::clear_umsgid() {
  umsgid_ = 0u;
  clear_has_umsgid();
}
inline ::google::protobuf::uint32 TmpTalkMsg::umsgid() const {
  return umsgid_;
}
inline void TmpTalkMsg::set_umsgid(::google::protobuf::uint32 value) {
  set_has_umsgid();
  umsgid_ = value;
}

// required bytes msg = 4;
inline bool TmpTalkMsg::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TmpTalkMsg::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TmpTalkMsg::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TmpTalkMsg::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& TmpTalkMsg::msg() const {
  return *msg_;
}
inline void TmpTalkMsg::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void TmpTalkMsg::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void TmpTalkMsg::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TmpTalkMsg::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* TmpTalkMsg::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TmpTalkMsg::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PullTalkMsgReq

// required uint32 uTargetID = 1 [default = 0];
inline bool PullTalkMsgReq::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PullTalkMsgReq::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PullTalkMsgReq::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PullTalkMsgReq::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 PullTalkMsgReq::utargetid() const {
  return utargetid_;
}
inline void PullTalkMsgReq::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// required uint32 uMsgID = 2 [default = 0];
inline bool PullTalkMsgReq::has_umsgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PullTalkMsgReq::set_has_umsgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PullTalkMsgReq::clear_has_umsgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PullTalkMsgReq::clear_umsgid() {
  umsgid_ = 0u;
  clear_has_umsgid();
}
inline ::google::protobuf::uint32 PullTalkMsgReq::umsgid() const {
  return umsgid_;
}
inline void PullTalkMsgReq::set_umsgid(::google::protobuf::uint32 value) {
  set_has_umsgid();
  umsgid_ = value;
}

// -------------------------------------------------------------------

// MsgInfoNotify_MsgInfo

// required uint32 uTargetID = 1 [default = 0];
inline bool MsgInfoNotify_MsgInfo::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgInfoNotify_MsgInfo::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgInfoNotify_MsgInfo::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgInfoNotify_MsgInfo::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 MsgInfoNotify_MsgInfo::utargetid() const {
  return utargetid_;
}
inline void MsgInfoNotify_MsgInfo::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// required uint32 uMsgID = 2 [default = 0];
inline bool MsgInfoNotify_MsgInfo::has_umsgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgInfoNotify_MsgInfo::set_has_umsgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgInfoNotify_MsgInfo::clear_has_umsgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgInfoNotify_MsgInfo::clear_umsgid() {
  umsgid_ = 0u;
  clear_has_umsgid();
}
inline ::google::protobuf::uint32 MsgInfoNotify_MsgInfo::umsgid() const {
  return umsgid_;
}
inline void MsgInfoNotify_MsgInfo::set_umsgid(::google::protobuf::uint32 value) {
  set_has_umsgid();
  umsgid_ = value;
}

// -------------------------------------------------------------------

// MsgInfoNotify

// repeated .tms.MsgInfoNotify.MsgInfo MsgInfos = 1;
inline int MsgInfoNotify::msginfos_size() const {
  return msginfos_.size();
}
inline void MsgInfoNotify::clear_msginfos() {
  msginfos_.Clear();
}
inline const ::tms::MsgInfoNotify_MsgInfo& MsgInfoNotify::msginfos(int index) const {
  return msginfos_.Get(index);
}
inline ::tms::MsgInfoNotify_MsgInfo* MsgInfoNotify::mutable_msginfos(int index) {
  return msginfos_.Mutable(index);
}
inline ::tms::MsgInfoNotify_MsgInfo* MsgInfoNotify::add_msginfos() {
  return msginfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::MsgInfoNotify_MsgInfo >&
MsgInfoNotify::msginfos() const {
  return msginfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::MsgInfoNotify_MsgInfo >*
MsgInfoNotify::mutable_msginfos() {
  return &msginfos_;
}

// -------------------------------------------------------------------

// TalkMsgInfo

// required uint32 uTargetID = 2 [default = 0];
inline bool TalkMsgInfo::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TalkMsgInfo::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TalkMsgInfo::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TalkMsgInfo::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 TalkMsgInfo::utargetid() const {
  return utargetid_;
}
inline void TalkMsgInfo::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// repeated .tms.TalkMsg TalkMsgs = 3;
inline int TalkMsgInfo::talkmsgs_size() const {
  return talkmsgs_.size();
}
inline void TalkMsgInfo::clear_talkmsgs() {
  talkmsgs_.Clear();
}
inline const ::tms::TalkMsg& TalkMsgInfo::talkmsgs(int index) const {
  return talkmsgs_.Get(index);
}
inline ::tms::TalkMsg* TalkMsgInfo::mutable_talkmsgs(int index) {
  return talkmsgs_.Mutable(index);
}
inline ::tms::TalkMsg* TalkMsgInfo::add_talkmsgs() {
  return talkmsgs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::TalkMsg >&
TalkMsgInfo::talkmsgs() const {
  return talkmsgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::TalkMsg >*
TalkMsgInfo::mutable_talkmsgs() {
  return &talkmsgs_;
}

// -------------------------------------------------------------------

// GroupPrivateInfo

// -------------------------------------------------------------------

// JoinGTalk

// required uint32 uTargetID = 1 [default = 0];
inline bool JoinGTalk::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGTalk::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGTalk::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGTalk::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 JoinGTalk::utargetid() const {
  return utargetid_;
}
inline void JoinGTalk::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// required uint32 uGTalkID = 2 [default = 0];
inline bool JoinGTalk::has_ugtalkid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinGTalk::set_has_ugtalkid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinGTalk::clear_has_ugtalkid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinGTalk::clear_ugtalkid() {
  ugtalkid_ = 0u;
  clear_has_ugtalkid();
}
inline ::google::protobuf::uint32 JoinGTalk::ugtalkid() const {
  return ugtalkid_;
}
inline void JoinGTalk::set_ugtalkid(::google::protobuf::uint32 value) {
  set_has_ugtalkid();
  ugtalkid_ = value;
}

// optional .tms.TargetInfo TargetInfos = 3;
inline bool JoinGTalk::has_targetinfos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinGTalk::set_has_targetinfos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinGTalk::clear_has_targetinfos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinGTalk::clear_targetinfos() {
  if (targetinfos_ != NULL) targetinfos_->::tms::TargetInfo::Clear();
  clear_has_targetinfos();
}
inline const ::tms::TargetInfo& JoinGTalk::targetinfos() const {
  return targetinfos_ != NULL ? *targetinfos_ : *default_instance_->targetinfos_;
}
inline ::tms::TargetInfo* JoinGTalk::mutable_targetinfos() {
  set_has_targetinfos();
  if (targetinfos_ == NULL) targetinfos_ = new ::tms::TargetInfo;
  return targetinfos_;
}
inline ::tms::TargetInfo* JoinGTalk::release_targetinfos() {
  clear_has_targetinfos();
  ::tms::TargetInfo* temp = targetinfos_;
  targetinfos_ = NULL;
  return temp;
}
inline void JoinGTalk::set_allocated_targetinfos(::tms::TargetInfo* targetinfos) {
  delete targetinfos_;
  targetinfos_ = targetinfos;
  if (targetinfos) {
    set_has_targetinfos();
  } else {
    clear_has_targetinfos();
  }
}

// -------------------------------------------------------------------

// AnsJoinGTalk

// required uint32 uTargetID = 1 [default = 0];
inline bool AnsJoinGTalk::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnsJoinGTalk::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnsJoinGTalk::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnsJoinGTalk::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 AnsJoinGTalk::utargetid() const {
  return utargetid_;
}
inline void AnsJoinGTalk::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// required uint32 uGTalkID = 2 [default = 0];
inline bool AnsJoinGTalk::has_ugtalkid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnsJoinGTalk::set_has_ugtalkid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnsJoinGTalk::clear_has_ugtalkid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnsJoinGTalk::clear_ugtalkid() {
  ugtalkid_ = 0u;
  clear_has_ugtalkid();
}
inline ::google::protobuf::uint32 AnsJoinGTalk::ugtalkid() const {
  return ugtalkid_;
}
inline void AnsJoinGTalk::set_ugtalkid(::google::protobuf::uint32 value) {
  set_has_ugtalkid();
  ugtalkid_ = value;
}

// -------------------------------------------------------------------

// QuitGTalk

// required uint32 uTargetID = 1 [default = 0];
inline bool QuitGTalk::has_utargetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuitGTalk::set_has_utargetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuitGTalk::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuitGTalk::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 QuitGTalk::utargetid() const {
  return utargetid_;
}
inline void QuitGTalk::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// required uint32 uGTalkID = 2 [default = 0];
inline bool QuitGTalk::has_ugtalkid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuitGTalk::set_has_ugtalkid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuitGTalk::clear_has_ugtalkid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuitGTalk::clear_ugtalkid() {
  ugtalkid_ = 0u;
  clear_has_ugtalkid();
}
inline ::google::protobuf::uint32 QuitGTalk::ugtalkid() const {
  return ugtalkid_;
}
inline void QuitGTalk::set_ugtalkid(::google::protobuf::uint32 value) {
  set_has_ugtalkid();
  ugtalkid_ = value;
}

// -------------------------------------------------------------------

// SysTargetInfo

// required uint32 uVersion = 1 [default = 0];
inline bool SysTargetInfo::has_uversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysTargetInfo::set_has_uversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysTargetInfo::clear_has_uversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysTargetInfo::clear_uversion() {
  uversion_ = 0u;
  clear_has_uversion();
}
inline ::google::protobuf::uint32 SysTargetInfo::uversion() const {
  return uversion_;
}
inline void SysTargetInfo::set_uversion(::google::protobuf::uint32 value) {
  set_has_uversion();
  uversion_ = value;
}

// required uint32 uTargetID = 2 [default = 0];
inline bool SysTargetInfo::has_utargetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysTargetInfo::set_has_utargetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysTargetInfo::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysTargetInfo::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 SysTargetInfo::utargetid() const {
  return utargetid_;
}
inline void SysTargetInfo::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// optional .tms.TargetInfo objs = 3;
inline bool SysTargetInfo::has_objs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysTargetInfo::set_has_objs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysTargetInfo::clear_has_objs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysTargetInfo::clear_objs() {
  if (objs_ != NULL) objs_->::tms::TargetInfo::Clear();
  clear_has_objs();
}
inline const ::tms::TargetInfo& SysTargetInfo::objs() const {
  return objs_ != NULL ? *objs_ : *default_instance_->objs_;
}
inline ::tms::TargetInfo* SysTargetInfo::mutable_objs() {
  set_has_objs();
  if (objs_ == NULL) objs_ = new ::tms::TargetInfo;
  return objs_;
}
inline ::tms::TargetInfo* SysTargetInfo::release_objs() {
  clear_has_objs();
  ::tms::TargetInfo* temp = objs_;
  objs_ = NULL;
  return temp;
}
inline void SysTargetInfo::set_allocated_objs(::tms::TargetInfo* objs) {
  delete objs_;
  objs_ = objs;
  if (objs) {
    set_has_objs();
  } else {
    clear_has_objs();
  }
}

// -------------------------------------------------------------------

// SysTargetInfoList

// repeated .tms.SysTargetInfo nodes = 2;
inline int SysTargetInfoList::nodes_size() const {
  return nodes_.size();
}
inline void SysTargetInfoList::clear_nodes() {
  nodes_.Clear();
}
inline const ::tms::SysTargetInfo& SysTargetInfoList::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::tms::SysTargetInfo* SysTargetInfoList::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::tms::SysTargetInfo* SysTargetInfoList::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::SysTargetInfo >&
SysTargetInfoList::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::SysTargetInfo >*
SysTargetInfoList::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// SysMemberInfo

// required uint32 uVersion = 1 [default = 0];
inline bool SysMemberInfo::has_uversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysMemberInfo::set_has_uversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysMemberInfo::clear_has_uversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysMemberInfo::clear_uversion() {
  uversion_ = 0u;
  clear_has_uversion();
}
inline ::google::protobuf::uint32 SysMemberInfo::uversion() const {
  return uversion_;
}
inline void SysMemberInfo::set_uversion(::google::protobuf::uint32 value) {
  set_has_uversion();
  uversion_ = value;
}

// required uint32 uTargetID = 2 [default = 0];
inline bool SysMemberInfo::has_utargetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysMemberInfo::set_has_utargetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysMemberInfo::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysMemberInfo::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 SysMemberInfo::utargetid() const {
  return utargetid_;
}
inline void SysMemberInfo::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// optional .tms.MemberInfo objs = 3;
inline bool SysMemberInfo::has_objs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysMemberInfo::set_has_objs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysMemberInfo::clear_has_objs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysMemberInfo::clear_objs() {
  if (objs_ != NULL) objs_->::tms::MemberInfo::Clear();
  clear_has_objs();
}
inline const ::tms::MemberInfo& SysMemberInfo::objs() const {
  return objs_ != NULL ? *objs_ : *default_instance_->objs_;
}
inline ::tms::MemberInfo* SysMemberInfo::mutable_objs() {
  set_has_objs();
  if (objs_ == NULL) objs_ = new ::tms::MemberInfo;
  return objs_;
}
inline ::tms::MemberInfo* SysMemberInfo::release_objs() {
  clear_has_objs();
  ::tms::MemberInfo* temp = objs_;
  objs_ = NULL;
  return temp;
}
inline void SysMemberInfo::set_allocated_objs(::tms::MemberInfo* objs) {
  delete objs_;
  objs_ = objs;
  if (objs) {
    set_has_objs();
  } else {
    clear_has_objs();
  }
}

// -------------------------------------------------------------------

// SysMemberInfoList

// required uint32 uVersion = 1 [default = 0];
inline bool SysMemberInfoList::has_uversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysMemberInfoList::set_has_uversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysMemberInfoList::clear_has_uversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysMemberInfoList::clear_uversion() {
  uversion_ = 0u;
  clear_has_uversion();
}
inline ::google::protobuf::uint32 SysMemberInfoList::uversion() const {
  return uversion_;
}
inline void SysMemberInfoList::set_uversion(::google::protobuf::uint32 value) {
  set_has_uversion();
  uversion_ = value;
}

// required uint32 uTargetID = 2 [default = 0];
inline bool SysMemberInfoList::has_utargetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysMemberInfoList::set_has_utargetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysMemberInfoList::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysMemberInfoList::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 SysMemberInfoList::utargetid() const {
  return utargetid_;
}
inline void SysMemberInfoList::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// repeated .tms.SysMemberInfo nodes = 3;
inline int SysMemberInfoList::nodes_size() const {
  return nodes_.size();
}
inline void SysMemberInfoList::clear_nodes() {
  nodes_.Clear();
}
inline const ::tms::SysMemberInfo& SysMemberInfoList::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::tms::SysMemberInfo* SysMemberInfoList::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::tms::SysMemberInfo* SysMemberInfoList::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::SysMemberInfo >&
SysMemberInfoList::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::SysMemberInfo >*
SysMemberInfoList::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// SysUserPrivateInfo

// required uint32 uVersion = 1 [default = 0];
inline bool SysUserPrivateInfo::has_uversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysUserPrivateInfo::set_has_uversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysUserPrivateInfo::clear_has_uversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysUserPrivateInfo::clear_uversion() {
  uversion_ = 0u;
  clear_has_uversion();
}
inline ::google::protobuf::uint32 SysUserPrivateInfo::uversion() const {
  return uversion_;
}
inline void SysUserPrivateInfo::set_uversion(::google::protobuf::uint32 value) {
  set_has_uversion();
  uversion_ = value;
}

// required uint32 uTargetID = 2 [default = 0];
inline bool SysUserPrivateInfo::has_utargetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysUserPrivateInfo::set_has_utargetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysUserPrivateInfo::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysUserPrivateInfo::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 SysUserPrivateInfo::utargetid() const {
  return utargetid_;
}
inline void SysUserPrivateInfo::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// optional .tms.UserPrivateInfo objs = 3;
inline bool SysUserPrivateInfo::has_objs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysUserPrivateInfo::set_has_objs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysUserPrivateInfo::clear_has_objs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysUserPrivateInfo::clear_objs() {
  if (objs_ != NULL) objs_->::tms::UserPrivateInfo::Clear();
  clear_has_objs();
}
inline const ::tms::UserPrivateInfo& SysUserPrivateInfo::objs() const {
  return objs_ != NULL ? *objs_ : *default_instance_->objs_;
}
inline ::tms::UserPrivateInfo* SysUserPrivateInfo::mutable_objs() {
  set_has_objs();
  if (objs_ == NULL) objs_ = new ::tms::UserPrivateInfo;
  return objs_;
}
inline ::tms::UserPrivateInfo* SysUserPrivateInfo::release_objs() {
  clear_has_objs();
  ::tms::UserPrivateInfo* temp = objs_;
  objs_ = NULL;
  return temp;
}
inline void SysUserPrivateInfo::set_allocated_objs(::tms::UserPrivateInfo* objs) {
  delete objs_;
  objs_ = objs;
  if (objs) {
    set_has_objs();
  } else {
    clear_has_objs();
  }
}

// -------------------------------------------------------------------

// SysUserPrivateInfoList

// repeated .tms.SysUserPrivateInfo nodes = 1;
inline int SysUserPrivateInfoList::nodes_size() const {
  return nodes_.size();
}
inline void SysUserPrivateInfoList::clear_nodes() {
  nodes_.Clear();
}
inline const ::tms::SysUserPrivateInfo& SysUserPrivateInfoList::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::tms::SysUserPrivateInfo* SysUserPrivateInfoList::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::tms::SysUserPrivateInfo* SysUserPrivateInfoList::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::SysUserPrivateInfo >&
SysUserPrivateInfoList::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::SysUserPrivateInfo >*
SysUserPrivateInfoList::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// SysGroupInfo

// required uint32 uVersion = 1 [default = 0];
inline bool SysGroupInfo::has_uversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysGroupInfo::set_has_uversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysGroupInfo::clear_has_uversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysGroupInfo::clear_uversion() {
  uversion_ = 0u;
  clear_has_uversion();
}
inline ::google::protobuf::uint32 SysGroupInfo::uversion() const {
  return uversion_;
}
inline void SysGroupInfo::set_uversion(::google::protobuf::uint32 value) {
  set_has_uversion();
  uversion_ = value;
}

// required uint32 uTargetID = 2 [default = 0];
inline bool SysGroupInfo::has_utargetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysGroupInfo::set_has_utargetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysGroupInfo::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysGroupInfo::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 SysGroupInfo::utargetid() const {
  return utargetid_;
}
inline void SysGroupInfo::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// optional .tms.GroupPrivateInfo objs = 4;
inline bool SysGroupInfo::has_objs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysGroupInfo::set_has_objs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysGroupInfo::clear_has_objs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysGroupInfo::clear_objs() {
  if (objs_ != NULL) objs_->::tms::GroupPrivateInfo::Clear();
  clear_has_objs();
}
inline const ::tms::GroupPrivateInfo& SysGroupInfo::objs() const {
  return objs_ != NULL ? *objs_ : *default_instance_->objs_;
}
inline ::tms::GroupPrivateInfo* SysGroupInfo::mutable_objs() {
  set_has_objs();
  if (objs_ == NULL) objs_ = new ::tms::GroupPrivateInfo;
  return objs_;
}
inline ::tms::GroupPrivateInfo* SysGroupInfo::release_objs() {
  clear_has_objs();
  ::tms::GroupPrivateInfo* temp = objs_;
  objs_ = NULL;
  return temp;
}
inline void SysGroupInfo::set_allocated_objs(::tms::GroupPrivateInfo* objs) {
  delete objs_;
  objs_ = objs;
  if (objs) {
    set_has_objs();
  } else {
    clear_has_objs();
  }
}

// -------------------------------------------------------------------

// SysGroupInfoList

// repeated .tms.SysGroupInfo nodes = 3;
inline int SysGroupInfoList::nodes_size() const {
  return nodes_.size();
}
inline void SysGroupInfoList::clear_nodes() {
  nodes_.Clear();
}
inline const ::tms::SysGroupInfo& SysGroupInfoList::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::tms::SysGroupInfo* SysGroupInfoList::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::tms::SysGroupInfo* SysGroupInfoList::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::SysGroupInfo >&
SysGroupInfoList::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::SysGroupInfo >*
SysGroupInfoList::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// SysGTalkInfoList

// required uint32 uVersion = 1 [default = 0];
inline bool SysGTalkInfoList::has_uversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysGTalkInfoList::set_has_uversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysGTalkInfoList::clear_has_uversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysGTalkInfoList::clear_uversion() {
  uversion_ = 0u;
  clear_has_uversion();
}
inline ::google::protobuf::uint32 SysGTalkInfoList::uversion() const {
  return uversion_;
}
inline void SysGTalkInfoList::set_uversion(::google::protobuf::uint32 value) {
  set_has_uversion();
  uversion_ = value;
}

// optional .tms.SysGroupInfoList objs = 3;
inline bool SysGTalkInfoList::has_objs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysGTalkInfoList::set_has_objs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysGTalkInfoList::clear_has_objs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysGTalkInfoList::clear_objs() {
  if (objs_ != NULL) objs_->::tms::SysGroupInfoList::Clear();
  clear_has_objs();
}
inline const ::tms::SysGroupInfoList& SysGTalkInfoList::objs() const {
  return objs_ != NULL ? *objs_ : *default_instance_->objs_;
}
inline ::tms::SysGroupInfoList* SysGTalkInfoList::mutable_objs() {
  set_has_objs();
  if (objs_ == NULL) objs_ = new ::tms::SysGroupInfoList;
  return objs_;
}
inline ::tms::SysGroupInfoList* SysGTalkInfoList::release_objs() {
  clear_has_objs();
  ::tms::SysGroupInfoList* temp = objs_;
  objs_ = NULL;
  return temp;
}
inline void SysGTalkInfoList::set_allocated_objs(::tms::SysGroupInfoList* objs) {
  delete objs_;
  objs_ = objs;
  if (objs) {
    set_has_objs();
  } else {
    clear_has_objs();
  }
}

// -------------------------------------------------------------------

// SysUserInfo

// required uint32 uVersion = 1 [default = 0];
inline bool SysUserInfo::has_uversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysUserInfo::set_has_uversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysUserInfo::clear_has_uversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysUserInfo::clear_uversion() {
  uversion_ = 0u;
  clear_has_uversion();
}
inline ::google::protobuf::uint32 SysUserInfo::uversion() const {
  return uversion_;
}
inline void SysUserInfo::set_uversion(::google::protobuf::uint32 value) {
  set_has_uversion();
  uversion_ = value;
}

// optional .tms.PrivateInfo PrivateInfos = 3;
inline bool SysUserInfo::has_privateinfos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysUserInfo::set_has_privateinfos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysUserInfo::clear_has_privateinfos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysUserInfo::clear_privateinfos() {
  if (privateinfos_ != NULL) privateinfos_->::tms::PrivateInfo::Clear();
  clear_has_privateinfos();
}
inline const ::tms::PrivateInfo& SysUserInfo::privateinfos() const {
  return privateinfos_ != NULL ? *privateinfos_ : *default_instance_->privateinfos_;
}
inline ::tms::PrivateInfo* SysUserInfo::mutable_privateinfos() {
  set_has_privateinfos();
  if (privateinfos_ == NULL) privateinfos_ = new ::tms::PrivateInfo;
  return privateinfos_;
}
inline ::tms::PrivateInfo* SysUserInfo::release_privateinfos() {
  clear_has_privateinfos();
  ::tms::PrivateInfo* temp = privateinfos_;
  privateinfos_ = NULL;
  return temp;
}
inline void SysUserInfo::set_allocated_privateinfos(::tms::PrivateInfo* privateinfos) {
  delete privateinfos_;
  privateinfos_ = privateinfos;
  if (privateinfos) {
    set_has_privateinfos();
  } else {
    clear_has_privateinfos();
  }
}

// -------------------------------------------------------------------

// SysTalkMsg

// required uint32 uVersion = 1 [default = 0];
inline bool SysTalkMsg::has_uversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysTalkMsg::set_has_uversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysTalkMsg::clear_has_uversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysTalkMsg::clear_uversion() {
  uversion_ = 0u;
  clear_has_uversion();
}
inline ::google::protobuf::uint32 SysTalkMsg::uversion() const {
  return uversion_;
}
inline void SysTalkMsg::set_uversion(::google::protobuf::uint32 value) {
  set_has_uversion();
  uversion_ = value;
}

// required uint32 uTargetID = 2 [default = 0];
inline bool SysTalkMsg::has_utargetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysTalkMsg::set_has_utargetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysTalkMsg::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysTalkMsg::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 SysTalkMsg::utargetid() const {
  return utargetid_;
}
inline void SysTalkMsg::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// repeated .tms.TalkMsg nodes = 3;
inline int SysTalkMsg::nodes_size() const {
  return nodes_.size();
}
inline void SysTalkMsg::clear_nodes() {
  nodes_.Clear();
}
inline const ::tms::TalkMsg& SysTalkMsg::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::tms::TalkMsg* SysTalkMsg::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::tms::TalkMsg* SysTalkMsg::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::TalkMsg >&
SysTalkMsg::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::TalkMsg >*
SysTalkMsg::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// SysTalkMsgList

// repeated .tms.SysTalkMsg nodes = 1;
inline int SysTalkMsgList::nodes_size() const {
  return nodes_.size();
}
inline void SysTalkMsgList::clear_nodes() {
  nodes_.Clear();
}
inline const ::tms::SysTalkMsg& SysTalkMsgList::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::tms::SysTalkMsg* SysTalkMsgList::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::tms::SysTalkMsg* SysTalkMsgList::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::SysTalkMsg >&
SysTalkMsgList::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::SysTalkMsg >*
SysTalkMsgList::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// SysTargetMsgInfo

// required uint32 uVersion = 1 [default = 0];
inline bool SysTargetMsgInfo::has_uversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysTargetMsgInfo::set_has_uversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysTargetMsgInfo::clear_has_uversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysTargetMsgInfo::clear_uversion() {
  uversion_ = 0u;
  clear_has_uversion();
}
inline ::google::protobuf::uint32 SysTargetMsgInfo::uversion() const {
  return uversion_;
}
inline void SysTargetMsgInfo::set_uversion(::google::protobuf::uint32 value) {
  set_has_uversion();
  uversion_ = value;
}

// required uint32 uTargetID = 2 [default = 0];
inline bool SysTargetMsgInfo::has_utargetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysTargetMsgInfo::set_has_utargetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysTargetMsgInfo::clear_has_utargetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysTargetMsgInfo::clear_utargetid() {
  utargetid_ = 0u;
  clear_has_utargetid();
}
inline ::google::protobuf::uint32 SysTargetMsgInfo::utargetid() const {
  return utargetid_;
}
inline void SysTargetMsgInfo::set_utargetid(::google::protobuf::uint32 value) {
  set_has_utargetid();
  utargetid_ = value;
}

// -------------------------------------------------------------------

// SysTargetMsgInfoList

// repeated .tms.SysTargetMsgInfo nodes = 1;
inline int SysTargetMsgInfoList::nodes_size() const {
  return nodes_.size();
}
inline void SysTargetMsgInfoList::clear_nodes() {
  nodes_.Clear();
}
inline const ::tms::SysTargetMsgInfo& SysTargetMsgInfoList::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::tms::SysTargetMsgInfo* SysTargetMsgInfoList::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::tms::SysTargetMsgInfo* SysTargetMsgInfoList::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tms::SysTargetMsgInfo >&
SysTargetMsgInfoList::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::tms::SysTargetMsgInfo >*
SysTargetMsgInfoList::mutable_nodes() {
  return &nodes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tms

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tms::UserInfoReq_cmd>() {
  return ::tms::UserInfoReq_cmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tms::TargetsAdd_cmd>() {
  return ::tms::TargetsAdd_cmd_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
